## V. Replicación y Alta Disponibilidad en PostgreSQL

La **replicación** y la **alta disponibilidad (HA)** permiten que tu base de datos siga operando incluso ante fallos de hardware, red o servicio, manteniendo una o más **copias actualizadas** de los datos.

---

## A. Concepto de Replicación

La **replicación en PostgreSQL** es el proceso de **copiar datos** desde un servidor principal (**primary**) hacia uno o varios servidores de réplica (**standby**):

- La réplica suele funcionar como un **espejo** del servidor principal.
- Puede estar en el **mismo servidor**, en otro **equipo** o incluso en otra **red / datacenter**.
- Permite:
  - **Alta disponibilidad**: seguir trabajando si el servidor principal falla (con failover).
  - **Distribución de carga de lectura**: enviar consultas de solo lectura a las réplicas.
  - **Recuperación ante desastres (DR)**.

---

## B. Tipos de Replicación en PostgreSQL

PostgreSQL soporta principalmente dos enfoques:

1. **Replicación física (streaming replication)** – Replica el *WAL* (Write-Ahead Log).
2. **Replicación lógica** – Replica datos a nivel de tablas (publicaciones/suscripciones).

### 1. Streaming Replication (física, en “tiempo real”)

La **Streaming Replication** replica los cambios desde el servidor **primary** a las réplicas usando los **registros WAL**.

- El primary **envía continuamente** los WAL a las réplicas.
- Las réplicas **reproducen** esos WAL para mantenerse actualizadas.

**Ventajas:**

- Muy útil para **alta disponibilidad**.
- Afecta poco el rendimiento del primary.
- Permite **escalar lecturas** (consultas de solo lectura en réplicas).

**Limitaciones:**

- Las réplicas pueden estar **ligeramente atrasadas** (retardo de replicación).
- Requiere monitoreo para evitar desincronización excesiva.

---

### 2. Replicación síncrona vs asíncrona

Estas son **modalidades** de la replicación física (streaming):

| Modalidad         | ¿Primary espera confirmación de réplica? | Riesgo de pérdida de datos | Latencia de escritura |
|-------------------|-------------------------------------------|----------------------------|------------------------|
| **Asíncrona**     | No                                       | Puede perder últimos cambios si cae el primary | Más baja               |
| **Síncrona**      | Sí (al menos una réplica)                | Casi nulo (durabilidad muy alta)              | Más alta               |

- **Replicación asíncrona**:
  - El primary **no espera** a las réplicas para confirmar la transacción.
  - **Más rápida**, pero podrías perder algunos registros recientes si el primary falla justo después de confirmar la transacción y antes de que la réplica reciba el WAL.

- **Replicación síncrona**:
  - El primary **espera** que al menos una réplica confirme la recepción del WAL.
  - Aumenta la **seguridad de los datos**, a cambio de más **latencia de escritura**.

Configuración típica de replicación síncrona (ejemplo conceptual en `postgresql.conf`):

```conf
synchronous_commit = on
synchronous_standby_names = 'REPLICA_1'
```

---

### 3. Replicación lógica

La **replicación lógica** permite replicar:

- Tablas específicas.
- Esquemas concretos.
- Solo ciertos cambios (insert, update, delete).

Es útil para:

- **Integraciones** entre sistemas.
- **Migraciones** progresivas entre versiones o servidores.
- Escenarios donde no quieres replicar **todo el clúster**, solo algunos objetos.

Flujo básico:

1. En el servidor **publicador** (origen): crear una **publicación**.
2. En el servidor **suscriptor** (destino): crear una **suscripción**.

Ejemplo:

```sql
-- En el servidor origen (publicador)
CREATE PUBLICATION pub_tienda
FOR TABLE productos, clientes;

-- En el servidor destino (suscriptor)
CREATE SUBSCRIPTION sub_tienda
CONNECTION 'host=origen port=5432 dbname=tienda user=replicador password=secreto'
PUBLICATION pub_tienda;
```

---

## C. Configuración básica de Streaming Replication

A continuación, un flujo simplificado de configuración de replicación física (streaming) entre:

- **Servidor primary**: `192.168.1.10`
- **Servidor standby**: `192.168.1.11`
- Usuario de replicación: `replicador`

> Nota: los pasos y detalles pueden variar según la versión (ejemplos pensados para PostgreSQL 12+).

---

### 1. Configuración en el servidor primary

#### 1.1. `postgresql.conf`

Editar (en el primary) el archivo `postgresql.conf`:

```conf
# Permitir suficientes WAL para replicación
wal_level = replica
max_wal_senders = 10
max_replication_slots = 5

# Permitir que las réplicas se conecten
listen_addresses = '*'

# (Opcional) Para permitir consultas de solo lectura en standby
hot_standby = on
```

Reiniciar PostgreSQL tras los cambios:

```bash
sudo systemctl restart postgresql
```

#### 1.2. `pg_hba.conf`

Permitir conexiones de replicación desde el servidor standby:

```conf
# Tipo BD   Usuario      Dirección          Método
host  replication replicador 192.168.1.11/32 md5
```

Recargar la configuración:

```bash
sudo systemctl reload postgresql
```

Crear el usuario de replicación:

```sql
CREATE ROLE replicador WITH REPLICATION LOGIN ENCRYPTED PASSWORD 'secreto';
```

---

### 2. Crear copia base hacia el standby

En el **servidor standby**, crear una copia base del primary.  
Método recomendado: `pg_basebackup`.

```bash
# Ejecutado en el standby
pg_basebackup \
  -h 192.168.1.10 \
  -p 5432 \
  -U replicador \
  -D /var/lib/postgresql/15/main \
  -Fp -Xs -P -R
```

Opciones clave:

- `-D` → directorio de datos del standby.
- `-R` → crea automáticamente archivos de configuración para standby (`standby.signal` y `postgresql.auto.conf` con `primary_conninfo`).
- `-Xs` → incluye WAL necesarios.

Esto generará en el standby un archivo con la conexión al primary, similar a:

```conf
primary_conninfo = 'host=192.168.1.10 port=5432 user=replicador password=secreto application_name=REPLICA_1'
```

---

### 3. Iniciar y verificar el standby

Iniciar PostgreSQL en el servidor standby:

```bash
sudo systemctl start postgresql
```

#### 3.1. Verificación de la replicación

En el **servidor primary**, podemos consultar el estado de las réplicas con la vista `pg_stat_replication`:

```sql
SELECT
    pid,
    client_addr        AS ip_standby,
    state,
    sync_state,
    write_lag,
    flush_lag,
    replay_lag
FROM pg_stat_replication;
```

Campos clave:

- `state` → estado de la réplica (`streaming`, `catchup`, etc.).
- `sync_state` → `sync`, `async`, `potential` (importante en replicación síncrona).
- `*_lag` → retardo en escritura, vaciado y reproducción de WAL.

En el **servidor standby**, podemos verificar si está funcionando como réplica:

```sql
SELECT pg_is_in_recovery() AS es_standby;
```

Debería devolver:

```text
 es_standby
------------
 t
(1 row)
```

Y confirmar que **no se permiten escrituras** (solo lectura):

```sql
INSERT INTO prueba (columna) VALUES ('test');
-- Debería fallar indicando que la base está en modo recuperación (read-only)
```

---

#### 3.2. Promoción del standby (failover manual)

Si el **primary falla** y necesitamos que el standby se convierta en el nuevo primary (promoción), existen varias formas.

En el **standby**, podemos ejecutar:

```sql
-- Promocionar standby desde SQL (PostgreSQL 12+)
SELECT pg_promote();
```

O desde el sistema operativo:

```bash
# Ejecutado en el servidor standby
pg_ctl -D /var/lib/postgresql/15/main promote
```

Después de la promoción:

- `pg_is_in_recovery()` devolverá `false`.
- El servidor aceptará **escrituras**.
- Este nodo pasa a ser el **nuevo primary**.

> En escenarios de alta disponibilidad real, esta promoción suele ser gestionada por herramientas de *cluster* o *orquestación* (ej. Patroni, Pacemaker, repmgr).

---

## D. Herramientas de Alta Disponibilidad y Failover

Además de la replicación nativa, existen herramientas que facilitan:

- **Failover automático** (promoción de réplica al caer el primary).
- **Supervisión de nodos**.
- **Balanceo de carga** de conexiones.
- Manejo de **clustering** y *pools* de conexiones.

### 1. Resumen de herramientas comunes

| Herramienta   | Rol principal                                  | Funcionalidades destacadas                                 |
|---------------|-----------------------------------------------|-----------------------------------------------------------|
| **Patroni**   | Orquestador de HA para PostgreSQL             | Failover automático, control de líder, usa etcd/Consul    |
| **pgBouncer** | Pool de conexiones ligero                     | Reutilización de conexiones, límite de conexiones al DB   |
| **Pgpool-II** | Middleware entre app y PostgreSQL             | Balanceo de carga, failover, pooling, replicación básica  |
| **Pacemaker** | Gestor de clúster HA (nivel SO)               | Gestión de recursos, failover de servicios en general     |
| **repmgr**    | Gestión de replicación y failover para PG     | Registro de nodos, clonación, failover y *switchover*     |

> En el texto original se mencionan herramientas similares; aquí se adopta la nomenclatura más común: `repmgr` como una solución usual para gestión y promoción de nodos.

---

### 2. Patroni: alta disponibilidad orquestada

**Patroni** es una solución especializada en PostgreSQL que:

- Gestiona **elección de líder** (primary).
- Controla **réplicas**.
- Efectúa **failover automático**.
- Usa un sistema de consenso (como **etcd**, **Consul**, **Zookeeper**) para coordinar nodos.

Configuración básica (ejemplo muy simplificado de `patroni.yml` para un nodo):

```yaml
scope: cluster-tienda
name: nodo1

restapi:
  listen: 0.0.0.0:8008
  connect_address: 192.168.1.10:8008

etcd:
  host: 192.168.1.100:2379

postgresql:
  listen: 0.0.0.0:5432
  connect_address: 192.168.1.10:5432
  data_dir: /var/lib/postgresql/15/main
  bin_dir: /usr/lib/postgresql/15/bin
  authentication:
    superuser:
      username: postgres
      password: secreto
    replication:
      username: replicador
      password: secreto_replica
  parameters:
    max_wal_senders: 10
    wal_level: replica
    hot_standby: on
```

Patroni se encarga de:

- Iniciar/stopear PostgreSQL.
- Promover réplicas cuando el líder falla.
- Mantener la configuración coherente en todos los nodos.

---

### 3. pgBouncer: *pooling* de conexiones

**pgBouncer** sirve como **proxy ligero** que se coloca entre la aplicación y PostgreSQL:

- Mantiene un **pool de conexiones** reutilizables.
- Reduce el costo de crear/destrozar conexiones frecuentemente.
- Puede reenviar conexiones a primary o réplicas según la estrategia.

Ejemplo sencillo de configuración (`pgbouncer.ini`):

```ini
[databases]
tienda = host=192.168.1.10 port=5432 dbname=tienda

[pgbouncer]
listen_addr = 0.0.0.0
listen_port = 6432
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt
pool_mode = transaction
max_client_conn = 1000
default_pool_size = 50
```

La aplicación en lugar de conectarse a `5432`, se conecta a `6432` (pgBouncer).

---

### 4. Pgpool-II: clustering y balanceo de carga

**Pgpool-II** es un middleware más completo que:

- Puede **balancear cargas de lectura** hacia réplicas.
- Ofrece ciertos mecanismos de **failover**.
- Proporciona **pooling** de conexiones.
- Puede gestionar **replicación**, aunque hoy suele preferirse la replicación nativa + Pgpool-II como proxy.

Ejemplo muy simplificado de configuración de nodos en `pgpool.conf`:

```conf
backend_hostname0 = '192.168.1.10'
backend_port0     = 5432
backend_weight0   = 1
backend_flag0     = 'PRIMARY'

backend_hostname1 = '192.168.1.11'
backend_port1     = 5432
backend_weight1   = 1
backend_flag1     = 'STANDBY'
```

---

### 5. Pacemaker y repmgr

- **Pacemaker**:
  - Trabaja a nivel de **sistema operativo**.
  - Gestiona múltiples recursos (no solo PostgreSQL).
  - En conjunto con **Corosync**, puede realizar **failover** de servicios entre nodos del clúster.

- **repmgr**:
  - Herramienta específica para PostgreSQL.
  - Facilita:
    - Registro y clonación de nodos.
    - Gestión de **replicación física**.
    - Scripts de **failover** y **switchover**.
  - Ejemplo de registro de nodo standby (muy simplificado):

```bash
repmgr -f /etc/repmgr.conf standby register
```

---

## E. Resumen: Replicación + Alta Disponibilidad

- La **replicación física (streaming)** mantiene **copias fieles** del clúster, ideal para HA y DR.
- La **replicación lógica** ofrece **flexibilidad** (tablas/esquemas específicos).
- La **síncrona** prioriza la **seguridad de datos**; la **asíncrona**, el **rendimiento**.
- Herramientas como **Patroni**, **pgBouncer**, **Pgpool-II**, **Pacemaker** y **repmgr** permiten construir soluciones de **alta disponibilidad completas**, con:
  - **Failover automático o controlado**.
  - **Balanceo de carga**.
  - **Gestión centralizada** de nodos.

Con estas piezas combinadas, es posible diseñar una arquitectura PostgreSQL **tolerante a fallos, escalable y preparada para producción**.