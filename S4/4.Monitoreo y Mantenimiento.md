## IV. Monitoreo y Mantenimiento en PostgreSQL

Esta sección aborda las funciones y herramientas necesarias para **supervisar** y **mantener** la base de datos, asegurando:

- **Buen rendimiento** constante.
- **Uso eficiente de espacio en disco**.
- **Detección y corrección temprana** de problemas de performance.

---

## A. Comandos de Mantenimiento

### 1. Objetivo del mantenimiento

El mantenimiento periódico busca:

- Mantener la base de datos **limpia de tuplas muertas**.
- Garantizar que el **optimizador** cuente con **estadísticas actualizadas**.
- Evitar **bloat** (crecimiento innecesario de tablas/índices).
- Prevenir **degradaciones de rendimiento** a mediano y largo plazo.

Las dos herramientas principales son:

- `VACUUM`
- `ANALYZE`

---

### 2. Tipos de `VACUUM`

`VACUUM` se encarga, principalmente, de **limpiar tuplas muertas** (registros borrados o actualizados que ya no son visibles) y **reciclar** ese espacio dentro de la tabla.

| Comando        | Función principal                                                   | Impacto en espacio en disco                |
|----------------|---------------------------------------------------------------------|--------------------------------------------|
| `VACUUM`       | Limpia tuplas muertas y marca espacio reutilizable                 | No reduce el tamaño del archivo en disco   |
| `VACUUM FULL`  | Limpia, **compacta** y reescribe la tabla                          | **Reduce** el tamaño del archivo en disco  |
| `VACUUM ANALYZE` | Limpia y además **actualiza estadísticas**                       | Similar a `VACUUM` + `ANALYZE`             |

> Nota: PostgreSQL también cuenta con **autovacuum**, que ejecuta estos procesos automáticamente, pero en muchos casos sigue siendo recomendable ejecutar mantenimiento manual en tablas críticas.

#### 2.1. Ejemplos de uso de `VACUUM`

**a) Vaciar una sola tabla**

```sql
VACUUM ventas;
```

**b) Vaciar toda la base de datos (todas las tablas)**

```sql
VACUUM;
```

**c) Compactar una tabla grande (cuidado: bloquea la tabla)**

```sql
VACUUM FULL ventas;
```

> Úsalo en ventanas de mantenimiento, ya que `VACUUM FULL` puede **bloquear** la tabla por el tiempo que dure el proceso.

**d) Combinar limpieza y actualización de estadísticas**

```sql
VACUUM ANALYZE ventas;
```

---

### 3. `ANALYZE`: actualización de estadísticas

`ANALYZE` se enfoca exclusivamente en **actualizar las estadísticas** que usa el planificador de consultas (optimizer) para decidir:

- Qué índices usar.
- El orden de las uniones (JOIN).
- Estrategias de acceso a los datos.

Tener estadísticas actualizadas es clave para **consultas rápidas**.

#### 3.1. Ejemplos de uso de `ANALYZE`

**a) Analizar una tabla específica**

```sql
ANALYZE clientes;
```

**b) Analizar una tabla y columnas específicas**

```sql
ANALYZE clientes (pais, ciudad);
```

**c) Analizar toda la base de datos**

```sql
ANALYZE;
```

> Buenas prácticas: ejecutar `ANALYZE` después de **cargas masivas**, **importaciones** o cambios grandes en los datos.

---

### 4. Automatización básica (idea general)

En entornos productivos, suele combinarse:

- **Autovacuum configurado adecuadamente**.
- Tareas programadas (cron, pgAgent, etc.) para:
  - `VACUUM ANALYZE` en tablas críticas.
  - `VACUUM FULL` ocasionalmente en tablas con mucho bloat.

Ejemplo simple de tarea programada en Linux con `cron` (conceptual):

```bash
# Ejecutar VACUUM ANALYZE cada noche a las 2 AM
0 2 * * * psql -U postgres -d tienda -c "VACUUM ANALYZE;"
```

---

## B. Herramientas de Monitoreo

### 1. Objetivo del monitoreo

Las herramientas de monitoreo de PostgreSQL permiten:

- Ver el **estado actual** de conexiones y consultas.
- Detectar **consultas lentas o bloqueadas**.
- Analizar **patrones de uso** a lo largo del tiempo.
- Tomar decisiones de **optimización** basadas en datos.

Dos vistas/extensiones clave son:

- `pg_stat_activity`
- `pg_stat_statements`

---

### 2. `pg_stat_activity`: monitoreo en tiempo real

`pg_stat_activity` muestra información de **todas las conexiones activas** al servidor:

- Usuario, base de datos, estado.
- Consulta actual.
- Momento de inicio.
- Si están esperando bloqueos, etc.

#### 2.1. Ver conexiones activas

```sql
SELECT
    pid,
    usename      AS usuario,
    datname      AS base_datos,
    state        AS estado,
    query_start  AS inicio_query,
    query
FROM pg_stat_activity
WHERE state <> 'idle'
ORDER BY query_start DESC;
```

Esto permite ver:

- Qué consultas se están ejecutando.
- Desde cuándo.
- Quién las lanzó.

---

#### 2.2. Detectar bloqueos

```sql
SELECT
    bl.pid              AS pid_bloqueado,
    bl.query            AS query_bloqueada,
    bl.query_start      AS inicio_bloqueada,
    lk.pid              AS pid_bloqueador,
    lk.query            AS query_bloqueadora,
    lk.query_start      AS inicio_bloqueadora
FROM pg_stat_activity bl
JOIN pg_locks l1 ON bl.pid = l1.pid AND NOT l1.granted
JOIN pg_locks l2 ON l1.locktype = l2.locktype
                AND l1.database IS NOT DISTINCT FROM l2.database
                AND l1.relation IS NOT DISTINCT FROM l2.relation
                AND l1.page IS NOT DISTINCT FROM l2.page
                AND l1.tuple IS NOT DISTINCT FROM l2.tuple
                AND l1.virtualxid IS NOT DISTINCT FROM l2.virtualxid
                AND l1.transactionid IS NOT DISTINCT FROM l2.transactionid
                AND l1.classid IS NOT DISTINCT FROM l2.classid
                AND l1.objid IS NOT DISTINCT FROM l2.objid
                AND l1.objsubid IS NOT DISTINCT FROM l2.objsubid
JOIN pg_stat_activity lk ON l2.pid = lk.pid
WHERE bl.pid <> lk.pid;
```

> Este tipo de consulta ayuda a identificar **qué sesión está bloqueando a cuál**, útil para diagnóstico de problemas de concurrencia.

---

#### 2.3. Cerrar una sesión problemática

Cuando una sesión está bloqueando o consumiendo demasiados recursos, se puede terminar:

```sql
SELECT pg_terminate_backend(12345); -- Reemplazar 12345 por el PID real
```

> Usar con cuidado: esto **cancela** la consulta y la conexión del cliente correspondiente.

---

### 3. `pg_stat_statements`: estadísticas históricas de consultas

`pg_stat_statements` es una **extensión** que guarda estadísticas agregadas sobre las consultas ejecutadas:

- Número de ejecuciones.
- Tiempo total y promedio.
- Lecturas desde disco y caché.
- Entre otros.

Se usa para:

- Identificar **consultas más costosas**.
- Ver **patrones de uso** a largo plazo.
- Priorizar qué queries optimizar.

---

#### 3.1. Activar `pg_stat_statements` (configuración básica)

1. **Habilitar la extensión en `postgresql.conf`**:

```conf
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.max = 10000
pg_stat_statements.track = all
```

2. **Reiniciar el servicio de PostgreSQL**.

3. **Crear la extensión en la base de datos** donde se usará:

```sql
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
```

---

#### 3.2. Consultar estadísticas de consultas

**a) Top 10 de consultas por tiempo total consumido**

```sql
SELECT
    query,
    calls,
    round(total_time::numeric, 2) AS tiempo_total_ms,
    round(mean_time::numeric, 2)  AS tiempo_promedio_ms
FROM pg_stat_statements
ORDER BY total_time DESC
LIMIT 10;
```

**b) Consultas más lentas en promedio**

```sql
SELECT
    query,
    calls,
    round(mean_time::numeric, 2) AS tiempo_promedio_ms
FROM pg_stat_statements
WHERE calls > 10         -- filtrar consultas que se ejecutaron varias veces
ORDER BY mean_time DESC
LIMIT 10;
```

**c) Resetear las estadísticas (por ejemplo, después de cambios de optimización)**

```sql
SELECT pg_stat_statements_reset();
```

> Útil cuando quieres medir el impacto de un cambio (nuevo índice, reescritura de consulta, etc.) a partir de “cero”.

---

## C. Resumen: Mantenimiento + Monitoreo

- **Mantenimiento (VACUUM / ANALYZE)**:
  - Limpia tuplas muertas.
  - Mantiene estadísticas al día.
  - Evita problemas de espacio y degradación de performance.

- **Monitoreo (`pg_stat_activity` / `pg_stat_statements`)**:
  - `pg_stat_activity` → vista **en tiempo real** de conexiones y consultas.
  - `pg_stat_statements` → visión **histórica y agregada** de las consultas.

Ambos aspectos, bien configurados y utilizados, son esenciales para operar una base de datos PostgreSQL **estable, rápida y fácil de administrar**.