## III. Optimización de Bases de Datos en PostgreSQL

En esta sección se abordan dos herramientas clave para optimizar el rendimiento y la administración de bases de datos en PostgreSQL:

- **Particionado de tablas**
- **Uso de tablespaces**

---

## A. Particionado de Tablas

### 1. ¿Qué es el particionado?

El **particionado de tablas** consiste en **dividir una tabla grande en subtablas más pequeñas (particiones)**, manteniendo una vista lógica única para el usuario.

- Es una característica **nativa** en PostgreSQL desde la versión **10**.
- Funciona de forma similar a otros motores como **Oracle**.

A nivel lógico, sigues trabajando con **una sola tabla**, pero PostgreSQL distribuye los datos en varias **particiones físicas**.

---

### 2. Beneficios del particionado

El particionado es fundamental para bases de datos con **grandes volúmenes de información**:

- Acelera las **consultas** (especialmente con filtros por la clave de particionado).
- Mejora el **rendimiento general** y el **mantenimiento**.
- Facilita la **eliminación de datos antiguos** (por ejemplo, por mes o año).
- Permite optimizar **índices** y **análisis** de forma más granular.

---

### 3. Tipos de particionado en PostgreSQL

PostgreSQL soporta varios tipos de particionado:

| Tipo       | Descripción                                        | Uso típico                            |
|-----------|----------------------------------------------------|---------------------------------------|
| RANGE     | Por **rango** de valores (fechas, números, etc.)   | Tablas históricas por fecha           |
| LIST      | Por **lista** de valores concretos                 | Datos categorizados (país, región)    |
| HASH      | Por **valor hash** de una columna                  | Distribución uniforme de cargas       |
| COMPOSITE | Combinación de los anteriores (multinivel)         | Escenarios complejos y de alto volumen|

---

### 4. Ejemplos de particionado

#### 4.1. Particionado por rango (RANGE)

Ejemplo: tabla de ventas particionada por año.

```sql
-- Tabla padre (particionada por rango en la columna fecha_venta)
CREATE TABLE ventas (
    id_venta      SERIAL PRIMARY KEY,
    fecha_venta   DATE NOT NULL,
    monto         NUMERIC(10,2),
    cliente_id    INT
) PARTITION BY RANGE (fecha_venta);

-- Partición para el año 2023
CREATE TABLE ventas_2023 PARTITION OF ventas
FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

-- Partición para el año 2024
CREATE TABLE ventas_2024 PARTITION OF ventas
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

Consulta de ejemplo (PostgreSQL decide a qué partición ir):

```sql
SELECT *
FROM ventas
WHERE fecha_venta BETWEEN '2023-03-01' AND '2023-03-31';
```

> PostgreSQL solo leerá la partición relevante (`ventas_2023`), reduciendo I/O y mejorando tiempos de respuesta.

---

#### 4.2. Particionado por lista (LIST)

Ejemplo: particionar clientes por país.

```sql
CREATE TABLE clientes (
    id_cliente  SERIAL PRIMARY KEY,
    nombre      TEXT NOT NULL,
    pais        TEXT NOT NULL
) PARTITION BY LIST (pais);

CREATE TABLE clientes_mx PARTITION OF clientes
FOR VALUES IN ('México');

CREATE TABLE clientes_co PARTITION OF clientes
FOR VALUES IN ('Colombia');

CREATE TABLE clientes_otros PARTITION OF clientes
FOR VALUES IN ('Chile', 'Perú', 'Argentina');
```

Consulta:

```sql
SELECT *
FROM clientes
WHERE pais = 'México';
```

---

#### 4.3. Particionado por hash (HASH)

Útil para **distribuir uniformemente** los datos y la carga.

```sql
CREATE TABLE logs (
    id_log      BIGSERIAL PRIMARY KEY,
    fecha       TIMESTAMP NOT NULL,
    usuario_id  INT NOT NULL,
    mensaje     TEXT
) PARTITION BY HASH (usuario_id);

CREATE TABLE logs_p0 PARTITION OF logs
FOR VALUES WITH (MODULUS 4, REMAINDER 0);

CREATE TABLE logs_p1 PARTITION OF logs
FOR VALUES WITH (MODULUS 4, REMAINDER 1);

CREATE TABLE logs_p2 PARTITION OF logs
FOR VALUES WITH (MODULUS 4, REMAINDER 2);

CREATE TABLE logs_p3 PARTITION OF logs
FOR VALUES WITH (MODULUS 4, REMAINDER 3);
```

---

#### 4.4. Particionado compuesto (COMPOSITE / multinivel)

Ejemplo: por **rango de fechas** y dentro de cada rango por **hash**:

```sql
-- Tabla padre particionada por rango
CREATE TABLE pedidos (
    id_pedido   BIGSERIAL PRIMARY KEY,
    fecha       DATE NOT NULL,
    cliente_id  INT,
    total       NUMERIC(10,2)
) PARTITION BY RANGE (fecha);

-- Partición por año 2024, internamente particionada por hash
CREATE TABLE pedidos_2024
PARTITION OF pedidos
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01')
PARTITION BY HASH (cliente_id);

CREATE TABLE pedidos_2024_p0 PARTITION OF pedidos_2024
FOR VALUES WITH (MODULUS 2, REMAINDER 0);

CREATE TABLE pedidos_2024_p1 PARTITION OF pedidos_2024
FOR VALUES WITH (MODULUS 2, REMAINDER 1);
```

---

## B. Uso de Tablespaces

### 1. ¿Qué es un tablespace?

Un **tablespace** es una **ubicación física en el sistema de archivos** donde PostgreSQL almacena:

- Tablas
- Índices
- Otros objetos de base de datos

Permite **controlar en qué disco** o ruta se guardan los datos.  
Su comportamiento es similar al concepto de tablespace en **Oracle**.

---

### 2. Beneficios de los tablespaces

Los tablespaces permiten:

- **Optimizar el rendimiento**, almacenando:
  - Tablas grandes en discos de alta capacidad.
  - Índices en discos más rápidos (por ejemplo, SSD).
- **Distribuir la carga** de lectura/escritura entre varios discos.
- Facilitar la **gestión del espacio** en sistemas de archivos (por aplicación, por tipo de dato, por criticidad, etc.).

---

### 3. Creación y uso de tablespaces

> Importante: El directorio del tablespace debe existir y tener permisos para el usuario del servicio PostgreSQL (por lo general `postgres`).

#### 3.1. Crear un tablespace

Ejemplo en Linux:

```bash
# Crear carpeta para el tablespace
sudo mkdir -p /mnt/ssd_datos/ts_rapido
sudo chown postgres:postgres /mnt/ssd_datos/ts_rapido
```

Crear el tablespace en PostgreSQL:

```sql
CREATE TABLESPACE ts_rapido
OWNER postgres
LOCATION '/mnt/ssd_datos/ts_rapido';
```

Podemos listar los tablespaces:

```sql
SELECT spcname, pg_tablespace_location(oid) AS ruta
FROM pg_tablespace;
```

---

#### 3.2. Crear tablas usando un tablespace específico

```sql
-- Tabla creada sobre el tablespace ts_rapido
CREATE TABLE ventas_criticas (
    id_venta    BIGSERIAL PRIMARY KEY,
    fecha       TIMESTAMP NOT NULL,
    monto       NUMERIC(10,2),
    cliente_id  INT
) TABLESPACE ts_rapido;
```

También podemos colocar **índices** en un tablespace distinto:

```sql
CREATE INDEX idx_ventas_criticas_fecha
ON ventas_criticas (fecha)
TABLESPACE ts_rapido;
```

---

#### 3.3. Mover una tabla a otro tablespace

Si ya existe una tabla, podemos moverla:

```sql
ALTER TABLE ventas_criticas
SET TABLESPACE ts_rapido;
```

Y para un índice:

```sql
ALTER INDEX idx_ventas_criticas_fecha
SET TABLESPACE ts_rapido;
```

---

## C. Particionado + Tablespaces: combinación potente

Una práctica común en sistemas con alto volumen es:

- **Particionar** una tabla grande (por fecha, por región, etc.).
- Ubicar **cada partición** en un tablespace distinto según:
  - Tipo de almacenamiento (SSD vs HDD).
  - Requerimientos de rendimiento.
  - Costos de almacenamiento.

Ejemplo simplificado:

```sql
CREATE TABLE ventas (
    id_venta    BIGSERIAL PRIMARY KEY,
    fecha       DATE NOT NULL,
    monto       NUMERIC(10,2)
) PARTITION BY RANGE (fecha);

CREATE TABLE ventas_2023 PARTITION OF ventas
FOR VALUES FROM ('2023-01-01') TO ('2024-01-01')
TABLESPACE ts_rapido;

CREATE TABLE ventas_2022 PARTITION OF ventas
FOR VALUES FROM ('2022-01-01') TO ('2023-01-01')
TABLESPACE ts_lento;  -- Por ejemplo, datos históricos menos consultados
```

---

## D. Analogía: Particionado vs Tablespace

> - El **particionado** es como organizar una **biblioteca enorme en secciones** (subtablas) por tema, año o categoría.  
>   Así, encontrar un libro específico (registro) es mucho más rápido y ordenado.
>
> - El **tablespace** es como decidir **en qué estantería física o sala** vas a guardar cada sección:  
>   puedes poner los libros más consultados (tablas activas) en estanterías rápidas y accesibles (discos SSD),  
>   y los menos consultados (históricos) en estanterías más económicas (discos más lentos).

Ambas técnicas, combinadas, permiten diseñar bases de datos **escálables, rápidas y fáciles de administrar**.