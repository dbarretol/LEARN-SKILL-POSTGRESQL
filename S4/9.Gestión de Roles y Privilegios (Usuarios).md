## IX. Gestión de Roles y Privilegios (Usuarios)

En esta sección se trabajó con la **creación de roles** y la **asignación de permisos** en PostgreSQL, mostrando cómo **controlar el acceso** y las **capacidades** de los usuarios dentro de la base de datos.

> Recomendación: aunque es posible crear roles con espacios en el nombre (`"admin tienda"`), es mucho más cómodo usar nombres sin espacios como `admin_tienda` o `manager_tienda`.

---

## A. Creación de Roles de Usuario

En PostgreSQL, **todo usuario es un rol con la capacidad de iniciar sesión** (`LOGIN`).  
Para la base de datos `tienda` se definieron dos perfiles:

- **Administrador** (`admin_tienda`) → superusuario.
- **Manager** (`manager_tienda`) → usuario estándar con permisos limitados.

### 1. Rol administrador: `admin_tienda` (SUPERUSER)

```sql
CREATE ROLE admin_tienda
    WITH LOGIN
    PASSWORD '123'
    SUPERUSER;
```

Características:

- Tiene permisos **ilimitados** sobre el clúster de PostgreSQL.
- Puede **crear bases de datos**, **crear roles**, y acceder a cualquier objeto.
- Se debe usar con **mucho cuidado** y preferiblemente solo para tareas de administración.

> Equivalente usando `CREATE USER` (alias de `CREATE ROLE ... LOGIN`):

```sql
CREATE USER admin_tienda
    WITH PASSWORD '123'
    SUPERUSER;
```

---

### 2. Rol manager: `manager_tienda` (usuario estándar)

```sql
CREATE ROLE manager_tienda
    WITH LOGIN
    PASSWORD '123'
    NOSUPERUSER;
```

Características:

- Puede conectarse a PostgreSQL, pero **no tiene privilegios** especiales por defecto.
- Necesita que se le **otorguen explícitamente permisos** sobre:
  - Base de datos.
  - Esquemas.
  - Tablas, vistas, etc.

---

## B. Pruebas de Acceso y “Permiso Denegado”

Con el rol `manager_tienda`, se intentó lo siguiente:

1. Conectarse a la base de datos `tienda`.
2. Ejecutar una consulta simple sobre una tabla, por ejemplo:

```sql
SELECT * FROM usuarios;
```

Resultado:

- PostgreSQL devolvió un error similar a:

```text
ERROR:  permission denied for table usuarios
```

Esto demuestra que:

- **Existir como rol** no es suficiente.
- Un usuario **no superusuario** necesita que el propietario (o un rol con permisos) utilice `GRANT` para permitirle trabajar con los objetos de la base de datos.

---

## C. Asignación de Privilegios con `GRANT`

La práctica mostró que:

- Usar únicamente `GRANT ALL PRIVILEGES ON DATABASE tienda TO manager_tienda;`
  **no otorga** permisos sobre las tablas.
- Es necesario distinguir entre:
  - Privilegios a nivel de **base de datos**.
  - Privilegios a nivel de **esquema**.
  - Privilegios a nivel de **tabla**.

A continuación se muestra una configuración correcta y típica.

> Asumimos:
> - Base de datos: `tienda`
> - Esquema principal: `public`
> - Tabla: `usuarios`

### 1. Privilegios a nivel de base de datos

Permitir que `manager_tienda` pueda **conectarse** a la base de datos `tienda`:

```sql
GRANT CONNECT ON DATABASE tienda TO manager_tienda;
```

> Nota: `GRANT ALL PRIVILEGES ON DATABASE` agrega permisos como:
> - `CONNECT`, `CREATE`, `TEMP`
> pero **no** concede automáticamente acceso a tablas ya creadas.

---

### 2. Privilegios a nivel de esquema

Para que un rol pueda usar objetos dentro de un esquema, necesita `USAGE` sobre el esquema:

```sql
GRANT USAGE ON SCHEMA public TO manager_tienda;
```

Opcionalmente, si deseas permitir que el manager pueda crear objetos nuevos en el esquema:

```sql
GRANT CREATE ON SCHEMA public TO manager_tienda;
```

---

### 3. Privilegios a nivel de tablas existentes

Para permitir que `manager_tienda` pueda hacer **SELECT** en todas las tablas actuales del esquema `public`:

```sql
GRANT SELECT ON ALL TABLES IN SCHEMA public TO manager_tienda;
```

Si solo quieres dar acceso a la tabla `usuarios`:

```sql
GRANT SELECT ON TABLE public.usuarios TO manager_tienda;
```

Luego, con el usuario `manager_tienda`:

```sql
SELECT * FROM public.usuarios;
-- Ahora debería funcionar si todos los GRANT se aplicaron correctamente
```

---

### 4. Privilegios por defecto para tablas nuevas

Si en el futuro se crean más tablas en el esquema `public`, **no heredarán automáticamente** los permisos de `GRANT SELECT ON ALL TABLES...`.

Para que las **tablas nuevas** creadas por un determinado rol (por ejemplo, el dueño de las tablas) otorguen automáticamente ciertos permisos a `manager_tienda`, se utilizan **privilegios por defecto**:

```sql
ALTER DEFAULT PRIVILEGES
    IN SCHEMA public
    GRANT SELECT ON TABLES TO manager_tienda;
```

Esto significa:

- Cada tabla nueva creada (por el rol que ejecuta `ALTER DEFAULT PRIVILEGES`) en el esquema `public`
  concederá automáticamente `SELECT` a `manager_tienda`.

---

## D. Ejemplo Completo: Configuración de `manager_tienda` para Solo-lectura

Supongamos que queremos que `manager_tienda` tenga:

- Permiso para **conectarse** a la base de datos `tienda`.
- Permiso para **consultar (SELECT)** cualquier tabla actual y futura del esquema `public`.
- Pero sin capacidad de modificar datos.

Como superusuario o dueño de la base:

```sql
-- 1. Permitir conexión a la base de datos
GRANT CONNECT ON DATABASE tienda TO manager_tienda;

-- 2. Permitir uso del esquema público
GRANT USAGE ON SCHEMA public TO manager_tienda;

-- 3. Dar SELECT sobre todas las tablas existentes
GRANT SELECT ON ALL TABLES IN SCHEMA public TO manager_tienda;

-- 4. Configurar privilegios por defecto para tablas futuras
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT SELECT ON TABLES TO manager_tienda;
```

Prueba con `manager_tienda`:

```sql
-- Conectado como manager_tienda
SELECT * FROM usuarios;       -- Debe funcionar
SELECT * FROM otra_tabla;     -- También, si está en public

-- Intento de escritura:
INSERT INTO usuarios (nombre, apellido, email, hash_clave)
VALUES ('Prueba', 'Manager', 'test@example.com', 'hash');
-- Debería fallar por falta de permisos de INSERT
```

---

## E. Lecciones de la Práctica

- Crear un rol con `LOGIN` **no le da acceso a nada** por sí mismo, salvo a lo que `public` tenga concedido (y esto suele estar endurecido en entornos productivos).
- `GRANT ALL PRIVILEGES ON DATABASE` **no incluye permisos sobre tablas** ya existentes.
- Es necesario:
  - `GRANT CONNECT` en la **base de datos**.
  - `GRANT USAGE` en el **esquema**.
  - `GRANT SELECT/INSERT/UPDATE/DELETE` en las **tablas**.
- Para nuevos objetos, se recomienda usar `ALTER DEFAULT PRIVILEGES` para definir una política de permisos predecible.

Con estos conceptos y comandos, puedes diseñar una política de seguridad clara:  
**administradores con control total** y **usuarios de negocio** con permisos ajustados a sus necesidades reales (solo lectura, lectura/escritura, etc.).