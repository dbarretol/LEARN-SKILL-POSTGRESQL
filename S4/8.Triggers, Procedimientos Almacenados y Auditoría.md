**VIII. Triggers, Procedimientos Almacenados y Auditoría (Práctica)**

**A. Creación de Estructuras para Auditoría (Auditoría Log y Auditoría Cambios)**

Para la práctica de auditoría, se comenzó con la creación de las tablas necesarias para registrar los cambios y acciones de los usuarios,.

**1. Tabla `auditoría log`:** Esta tabla fue diseñada para registrar las acciones principales realizadas. Sus campos definidos son:
*   **`log ID`**: Utilizando el tipo de dato `big serial` y definido como `primary key`.
*   **`tabla afectada`**: Tipo `varchar`, con la restricción de `not null`.
*   **`operación`**: Tipo `varchar(20)`, con la restricción `not null` y un *check* explícito para que solo acepte los valores `inserción`, `day` (o `update`), o `delite`,.
*   **`registro ID`**: Campo para guardar el ID del registro afectado.
*   **`usuario ID`**: Para registrar quién realizó la operación, referenciando a la tabla `usuarios` (la tabla a la que se le haría la auditoría),.
*   **`fecha hora`**: Utilizando el tipo `timestamp` con `current_timestamp` por defecto,.
*   **`IP origen`**: Tipo `varchar(50)` para registrar la dirección IP de donde se originó el cambio.
*   **`datos anteriores` y `datos nuevos`**: Ambos de tipo `text`, diseñados para guardar el estado del registro antes y después del cambio,.

**2. Tabla `auditoría cambios`:** Se creó una segunda tabla para almacenar modificaciones específicas o por columna,. Sus campos principales son:
*   **`ID`**: Tipo `big serial` y `primary key`.
*   **Referencia a `auditoría log`**: Contiene una referencia para vincular el cambio específico a la entrada general de la auditoría.
*   **`columna`**: Tipo `varchar`.
*   **`valor anterior` y `valor nuevo`**: Ambos de tipo `text`.

**B. Creación de Índices para Mejorar el Rendimiento de Consultas en Tablas de Auditoría**

Para asegurar que las consultas sobre las tablas de auditoría (que tienden a ser voluminosas) sean rápidas, se crearon índices. El objetivo de los índices es **mejorar el rendimiento** de las consultas.

Se generaron índices específicos en los siguientes campos de las tablas de auditoría,,,:
*   `tabla afectada`
*   `operación`
*   `usuario ID`
*   `fecha hora`

**C. Desarrollo de Función General de Auditoría: Intento de crear una función `PL/pgSQL` para manejar automáticamente operaciones (Insert, Update, Delete) en múltiples tablas**

Se consideró que, para tener una auditoría eficiente, era recomendable **crear una función general** que pudiera manejar automáticamente la inserción, actualización, y eliminación en **múltiples tablas**,.

1.  **Definición y Lenguaje:** La función se definió como `función_auditoría_general` con el propósito de retornar un *trigger*. El lenguaje utilizado para su programación fue **PL/pgSQL**.
2.  **Lógica Interna:** Dentro de la función, se estableció la lógica para:
    *   **Capturar Variables:** Se declaró y se intentó obtener el `usuario ID` (convirtiendo el usuario del sistema a `bigint`) y la `IP origen` (utilizando funciones del sistema como `client_address`),,.
    *   **Manejo Condicional:** Se usó la estructura `IF / ELSE IF` para diferenciar las acciones,,:
        *   Si la operación (`TG_OP`) era **INSERT**, se insertaba el registro en `auditoría log` utilizando `TG_TABLE_NAME` y capturando los datos nuevos con la función `to_jsonb(new)`,,.
        *   Si la operación era **UPDATE**, la lógica era similar, pero se capturaban tanto los `datos anteriores` (usando `old`) como los `datos nuevos` (usando `new`),.
        *   Si la operación era **DELETE**, se capturaban los `datos anteriores` (usando `old`),.
3.  **Resultado Práctico y Desafío:** A pesar de la construcción detallada, la función general de auditoría encontró **problemas de compatibilidad** y errores de campo (como la referencia incorrecta a `auditoría ID` o `registro ID`) durante la ejecución, y el *trigger* dependiente **no se guardó correctamente** al momento de la práctica,,,. Por esta razón, la corrección de la función y la verificación de la auditoría quedaron **pendientes** para ser revisadas en la siguiente sesión,,.

**D. Procedimiento Almacenado para Insertar Usuarios**

Se creó un procedimiento almacenado llamado `insertar_usuario` con el objetivo de gestionar la inserción de nuevos registros en la tabla `usuarios`,.

**1. Lógica: Verificar existencia de email único antes de la inserción**
Debido a que la tabla `usuarios` tenía una restricción de unicidad en el campo `email`, la lógica del procedimiento incluyó una verificación previa para **evitar errores de duplicidad** antes de intentar la inserción.
*   Se usó un *select* para intentar obtener el `usuario_id` del usuario cuyo *email* coincidiera con el parámetro de entrada (`P_email`).
*   Si el `usuario_ID` ya existía, el procedimiento estaba diseñado para mostrar un mensaje de error (`RISC NOTICE`) indicando que **el email ya estaba registrado**, proporcionando tanto el email como el ID del usuario existente.

**2. Inserción de datos y retorno del ID de usuario insertado**
*   Si la verificación determinaba que el usuario no existía, el procedimiento procedía con la inserción (`INSERT INTO usuarios`).
*   Se insertaban todos los parámetros de entrada (`P_nombre`, `P_apellido`, `P_email`, `P_hash`, etc.) en los campos correspondientes de la tabla `usuarios`,.
*   El procedimiento utilizó la cláusula **`RETURNING usuario_ID INTO [parámetro]`** para capturar el ID generado por el sistema y poder mostrar el último ID insertado al finalizar la operación,.
*   Tras resolver problemas de sintaxis y la eliminación de estructuras fallidas,, el procedimiento fue ejecutado con éxito, logrando la inserción del nuevo registro de usuario.