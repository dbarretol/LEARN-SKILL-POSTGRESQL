## VIII. Triggers, Procedimientos Almacenados y Auditoría (Práctica)

En esta sección se muestra cómo construir un **esquema de auditoría** en PostgreSQL usando:

- **Tablas de auditoría** para registrar operaciones.
- **Triggers** y una **función genérica de auditoría**.
- Un **procedimiento/función almacenada** para inserción controlada de usuarios.

---

## A. Tablas de Auditoría

Se diseñaron dos tablas:

1. `auditoria_log` → Registro general de cada operación (INSERT, UPDATE, DELETE).
2. `auditoria_cambios` → Detalle por columna, vinculado a `auditoria_log`.

### 1. Tabla `auditoria_log`

```sql
CREATE TABLE auditoria_log (
    log_id         BIGSERIAL PRIMARY KEY,
    tabla_afectada VARCHAR(100) NOT NULL,
    operacion      VARCHAR(20)  NOT NULL CHECK (
                        operacion IN ('INSERT', 'UPDATE', 'DELETE')
                    ),
    registro_id    BIGINT,               -- ID del registro afectado
    usuario_id     BIGINT,               -- Referencia a la tabla usuarios (opcional FK)
    fecha_hora     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ip_origen      VARCHAR(50),
    datos_anteriores TEXT,               -- JSON/Text con el estado previo
    datos_nuevos     TEXT                -- JSON/Text con el estado posterior
);
```

**Descripción simplificada:**

| Campo             | Tipo          | Descripción                                           |
|-------------------|---------------|-------------------------------------------------------|
| `log_id`          | `BIGSERIAL`   | Identificador único del evento de auditoría.         |
| `tabla_afectada`  | `VARCHAR`     | Nombre de la tabla donde ocurrió el cambio.          |
| `operacion`       | `VARCHAR(20)` | Tipo de operación: `INSERT`, `UPDATE`, `DELETE`.     |
| `registro_id`     | `BIGINT`      | ID del registro afectado (si aplica).                |
| `usuario_id`      | `BIGINT`      | Usuario que realizó la operación.                    |
| `fecha_hora`      | `TIMESTAMP`   | Momento del cambio (default `CURRENT_TIMESTAMP`).    |
| `ip_origen`       | `VARCHAR(50)` | IP desde la que se ejecutó la operación.             |
| `datos_anteriores`| `TEXT`        | Estado previo del registro en formato texto/JSON.    |
| `datos_nuevos`    | `TEXT`        | Estado nuevo del registro en formato texto/JSON.     |

---

### 2. Tabla `auditoria_cambios`

```sql
CREATE TABLE auditoria_cambios (
    id                 BIGSERIAL PRIMARY KEY,
    auditoria_log_id   BIGINT NOT NULL REFERENCES auditoria_log (log_id),
    columna            VARCHAR(100) NOT NULL,
    valor_anterior     TEXT,
    valor_nuevo        TEXT
);
```

**Descripción:**

| Campo             | Tipo        | Descripción                                      |
|-------------------|-------------|--------------------------------------------------|
| `id`              | `BIGSERIAL` | Identificador único del detalle de cambio.      |
| `auditoria_log_id`| `BIGINT`    | Referencia a la entrada de `auditoria_log`.     |
| `columna`         | `VARCHAR`   | Nombre de la columna modificada.                |
| `valor_anterior`  | `TEXT`      | Valor previo de esa columna.                    |
| `valor_nuevo`     | `TEXT`      | Valor nuevo de esa columna.                     |

---

## B. Índices para Mejorar el Rendimiento

Las tablas de auditoría suelen crecer rápidamente; por ello es importante crear índices que aceleren las consultas más frecuentes.

```sql
-- Índices sobre auditoria_log
CREATE INDEX idx_auditoria_log_tabla
    ON auditoria_log (tabla_afectada);

CREATE INDEX idx_auditoria_log_operacion
    ON auditoria_log (operacion);

CREATE INDEX idx_auditoria_log_usuario
    ON auditoria_log (usuario_id);

CREATE INDEX idx_auditoria_log_fecha
    ON auditoria_log (fecha_hora);
```

Ejemplo de consulta típica que se beneficia de estos índices:

```sql
SELECT *
FROM auditoria_log
WHERE tabla_afectada = 'usuarios'
  AND usuario_id = 123
ORDER BY fecha_hora DESC
LIMIT 50;
```

---

## C. Función General de Auditoría (Trigger)

La idea es crear una **función genérica** que:

- Se pueda reutilizar en **múltiples tablas**.
- Registre de forma automática:
  - Operación (`INSERT`, `UPDATE`, `DELETE`).
  - Tabla afectada.
  - ID del registro (si hay clave primaria).
  - Usuario (si se puede deducir).
  - IP de origen (si aplica).
  - Datos anteriores y nuevos en formato JSON.

### 1. Función `fn_auditoria_general()`

Ejemplo simplificado y funcional en **PL/pgSQL**:

```sql
CREATE OR REPLACE FUNCTION fn_auditoria_general()
RETURNS TRIGGER AS
$$
DECLARE
    v_log_id      BIGINT;
    v_usuario_id  BIGINT;
    v_ip_origen   TEXT;
BEGIN
    -- Ejemplo: intentar obtener el id de usuario desde la sesión (opcional)
    -- Puede venir de current_user, de una variable de aplicación, etc.
    -- Aquí se deja como NULL, o se puede mapear con una tabla de usuarios.
    v_usuario_id := NULL;

    -- Ejemplo: obtener la IP del cliente (si está disponible)
    BEGIN
        v_ip_origen := inet_client_addr()::TEXT;
    EXCEPTION WHEN OTHERS THEN
        v_ip_origen := NULL;
    END;

    -- INSERT
    IF TG_OP = 'INSERT' THEN
        INSERT INTO auditoria_log (
            tabla_afectada,
            operacion,
            registro_id,
            usuario_id,
            ip_origen,
            datos_anteriores,
            datos_nuevos
        )
        VALUES (
            TG_TABLE_NAME,
            'INSERT',
            NEW.id,                      -- Asume que la PK se llama "id"
            v_usuario_id,
            v_ip_origen,
            NULL,
            to_jsonb(NEW)::TEXT
        )
        RETURNING log_id INTO v_log_id;

        RETURN NEW;

    -- UPDATE
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO auditoria_log (
            tabla_afectada,
            operacion,
            registro_id,
            usuario_id,
            ip_origen,
            datos_anteriores,
            datos_nuevos
        )
        VALUES (
            TG_TABLE_NAME,
            'UPDATE',
            NEW.id,
            v_usuario_id,
            v_ip_origen,
            to_jsonb(OLD)::TEXT,
            to_jsonb(NEW)::TEXT
        )
        RETURNING log_id INTO v_log_id;

        RETURN NEW;

    -- DELETE
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO auditoria_log (
            tabla_afectada,
            operacion,
            registro_id,
            usuario_id,
            ip_origen,
            datos_anteriores,
            datos_nuevos
        )
        VALUES (
            TG_TABLE_NAME,
            'DELETE',
            OLD.id,
            v_usuario_id,
            v_ip_origen,
            to_jsonb(OLD)::TEXT,
            NULL
        )
        RETURNING log_id INTO v_log_id;

        RETURN OLD;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

> Nota:
> - Este ejemplo asume que las tablas auditadas tienen una columna de clave primaria llamada **`id`**.
> - Para manejar otras PK (ej. `usuario_id`, `producto_id`), se puede:
>   - Estandarizar el nombre de la PK.
>   - O agregar lógica adicional dentro de la función.

---

### 2. Creación de trigger en una tabla (ejemplo: `usuarios`)

Supongamos una tabla `usuarios`:

```sql
CREATE TABLE usuarios (
    usuario_id  BIGSERIAL PRIMARY KEY,
    nombre      VARCHAR(100) NOT NULL,
    apellido    VARCHAR(100) NOT NULL,
    email       VARCHAR(200) NOT NULL UNIQUE,
    hash_clave  TEXT NOT NULL,
    activo      BOOLEAN NOT NULL DEFAULT TRUE
);
```

Podemos:

1. Ajustar la función de auditoría para que use `usuario_id` como PK, o  
2. Crear una versión específica para `usuarios`.

Versión específica para `usuarios`:

```sql
CREATE OR REPLACE FUNCTION fn_auditoria_usuarios()
RETURNS TRIGGER AS
$$
DECLARE
    v_log_id      BIGINT;
    v_usuario_id  BIGINT;
    v_ip_origen   TEXT;
BEGIN
    -- En este caso, usuario_id podría venir del contexto de sesión
    v_usuario_id := NULL;

    BEGIN
        v_ip_origen := inet_client_addr()::TEXT;
    EXCEPTION WHEN OTHERS THEN
        v_ip_origen := NULL;
    END;

    IF TG_OP = 'INSERT' THEN
        INSERT INTO auditoria_log (
            tabla_afectada, operacion, registro_id,
            usuario_id, ip_origen, datos_anteriores, datos_nuevos
        )
        VALUES (
            TG_TABLE_NAME, 'INSERT', NEW.usuario_id,
            v_usuario_id, v_ip_origen,
            NULL, to_jsonb(NEW)::TEXT
        );

        RETURN NEW;

    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO auditoria_log (
            tabla_afectada, operacion, registro_id,
            usuario_id, ip_origen, datos_anteriores, datos_nuevos
        )
        VALUES (
            TG_TABLE_NAME, 'UPDATE', NEW.usuario_id,
            v_usuario_id, v_ip_origen,
            to_jsonb(OLD)::TEXT, to_jsonb(NEW)::TEXT
        );

        RETURN NEW;

    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO auditoria_log (
            tabla_afectada, operacion, registro_id,
            usuario_id, ip_origen, datos_anteriores, datos_nuevos
        )
        VALUES (
            TG_TABLE_NAME, 'DELETE', OLD.usuario_id,
            v_usuario_id, v_ip_origen,
            to_jsonb(OLD)::TEXT, NULL
        );

        RETURN OLD;
    END IF;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;
```

Creación del trigger:

```sql
CREATE TRIGGER trg_usuarios_auditoria
AFTER INSERT OR UPDATE OR DELETE
ON usuarios
FOR EACH ROW
EXECUTE FUNCTION fn_auditoria_usuarios();
```

---

## D. Procedimiento Almacenado para Insertar Usuarios

Se definió un procedimiento/función almacenada `insertar_usuario` para:

- Verificar que el **email sea único** antes de insertar.
- Insertar el usuario solo si no existe otro con el mismo email.
- Devolver el **ID del usuario** insertado.

### 1. Función `insertar_usuario` en PL/pgSQL

```sql
CREATE OR REPLACE FUNCTION insertar_usuario(
    p_nombre   VARCHAR,
    p_apellido VARCHAR,
    p_email    VARCHAR,
    p_hash     TEXT
)
RETURNS BIGINT AS
$$
DECLARE
    v_usuario_id BIGINT;
BEGIN
    -- Verificar si ya existe un usuario con ese email
    SELECT usuario_id
    INTO v_usuario_id
    FROM usuarios
    WHERE email = p_email;

    IF FOUND THEN
        RAISE EXCEPTION 'El email % ya está registrado con usuario_id=%',
            p_email, v_usuario_id;
    END IF;

    -- Insertar nuevo usuario
    INSERT INTO usuarios (nombre, apellido, email, hash_clave)
    VALUES (p_nombre, p_apellido, p_email, p_hash)
    RETURNING usuario_id INTO v_usuario_id;

    -- Devolver el ID insertado
    RETURN v_usuario_id;
END;
$$ LANGUAGE plpgsql;
```

> Alternativamente, en versiones modernas de PostgreSQL, se podría usar un `PROCEDURE` con `CALL`, pero el patrón con `FUNCTION` que retorna el ID es muy práctico.

### 2. Ejemplo de uso

```sql
SELECT insertar_usuario(
    p_nombre   => 'Juan',
    p_apellido => 'Pérez',
    p_email    => 'juan.perez@example.com',
    p_hash     => 'hash_encriptado'
) AS nuevo_usuario_id;
```

Si el email ya existe, se lanzará una excepción:

```text
ERROR:  El email juan.perez@example.com ya está registrado con usuario_id=5
```

En aplicaciones (Java, Python, etc.), esta excepción se puede capturar para mostrar un mensaje amigable al usuario.

---

## E. Resumen

- Se definieron **dos tablas de auditoría** (`auditoria_log` y `auditoria_cambios`) para registrar operaciones y cambios por columna.
- Se crearon **índices** para mejorar el rendimiento de consultas sobre tablas de auditoría.
- Se implementó una **función de auditoría genérica** (y una variante específica para `usuarios`) usando **triggers**.
- Se desarrolló una **función almacenada `insertar_usuario`** que:
  - Verifica la **unicidad del email**.
  - Inserta el registro solo si no existe un usuario con ese email.
  - Devuelve el **ID del nuevo usuario**.

Con estas piezas, dispones de una base sólida para implementar **auditoría y lógica de negocio controlada** en tus bases de datos PostgreSQL.