## VI. Migración y Compatibilidad

La **migración a PostgreSQL** consiste en mover datos y estructuras desde otros motores (como **SQL Server**, **MySQL** u **Oracle**) hacia PostgreSQL.  
Este proceso no es solo “copiar y pegar” SQL: requiere **ajustar scripts, tipos de datos y procedimientos almacenados** para que sean compatibles con el motor de destino.

---

## A. Desafíos Generales de Migración

### 1. Diferencias de características entre motores

Cada gestor de base de datos tiene:

- Funciones internas propias.
- Tipos de datos específicos.
- Sintaxis particular para índices, constraints, triggers, etc.
- Herramientas de administración y seguridad distintas.

Por ello, al migrar es necesario:

- **Revisar el esquema** (tablas, índices, constraints).
- **Analizar dependencias** (procedimientos, vistas, jobs).
- **Ajustar o reescribir** lo que no existe en PostgreSQL.

---

### 2. Tipos de datos sin equivalencia directa

Muchos tipos tienen un mapeo directo, pero otros no.  
Ejemplo típico: SQL Server → PostgreSQL.

| SQL Server          | PostgreSQL        | Comentario                                     |
|---------------------|-------------------|-----------------------------------------------|
| `INT`               | `INTEGER`         | Compatible                                     |
| `BIGINT`            | `BIGINT`          | Compatible                                     |
| `NVARCHAR(n)`       | `VARCHAR(n)`      | Usar UTF-8 en PostgreSQL                     |
| `DATETIME`          | `TIMESTAMP`       | Ajustar precisión si es necesario            |
| `MONEY`             | `NUMERIC(19,4)`   | Controlar precisión                           |
| `BIT`               | `BOOLEAN`         | 0 → FALSE, 1 → TRUE                          |
| `UNIQUEIDENTIFIER`  | `UUID`            | Requiere extensión/función para generarlo    |

Ejemplo de conversión de columna `uniqueidentifier`:

**SQL Server:**

```sql
CREATE TABLE Clientes (
    IdCliente UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    Nombre    NVARCHAR(100) NOT NULL
);
```

**PostgreSQL:**

```sql
-- Requiere extensión para generar UUID (una opción común)
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE clientes (
    id_cliente UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nombre     VARCHAR(100) NOT NULL
);
```

---

### 3. Procedimientos almacenados y funciones

Los lenguajes de programación interna difieren:

- **SQL Server** → `Transact-SQL (T-SQL)`
- **PostgreSQL** → `PL/pgSQL` (entre otros: PL/Python, PL/Perl, etc.)

Implicaciones:

- **Procedimientos almacenados** deben ser **reescritos**.
- Funciones nativas como `GETDATE()`, `NEWID()`, `ISNULL()` deben mapearse a equivalentes:

| SQL Server   | PostgreSQL               |
|--------------|--------------------------|
| `GETDATE()`  | `NOW()` o `CURRENT_TIMESTAMP` |
| `NEWID()`    | `gen_random_uuid()` (pgcrypto) |
| `ISNULL(a,b)`| `COALESCE(a,b)`          |
| `LEN(cad)`   | `LENGTH(cad)`            |

Ejemplo de conversión básica de procedimiento:

**SQL Server (T-SQL):**

```sql
CREATE PROCEDURE GetClientesActivos
AS
BEGIN
    SELECT IdCliente, Nombre
    FROM Clientes
    WHERE Activo = 1;
END;
```

**PostgreSQL (PL/pgSQL):**

```sql
CREATE OR REPLACE FUNCTION get_clientes_activos()
RETURNS SETOF clientes AS
$$
BEGIN
    RETURN QUERY
    SELECT id_cliente, nombre
    FROM clientes
    WHERE activo = TRUE;
END;
$$ LANGUAGE plpgsql;
```

Uso:

```sql
SELECT * FROM get_clientes_activos();
```

---

## B. Migración desde SQL Server a PostgreSQL

### 1. Consideraciones clave

#### a) Tipos de datos

Además del `UNIQUEIDENTIFIER`, otros ajustes comunes:

| SQL Server           | PostgreSQL                |
|----------------------|---------------------------|
| `BIT`                | `BOOLEAN`                 |
| `TINYINT` (0–255)    | `SMALLINT` o `INTEGER`    |
| `DATETIME2`          | `TIMESTAMP`               |
| `IMAGE`, `TEXT`      | `BYTEA`, `TEXT`           |
| `VARCHAR(MAX)`       | `TEXT`                    |

#### b) Sintaxis (ejemplos típicos)

**SQL Server:**

```sql
SELECT TOP 10 *
FROM Productos
ORDER BY FechaCreacion DESC;
```

**PostgreSQL:**

```sql
SELECT *
FROM productos
ORDER BY fecha_creacion DESC
LIMIT 10;
```

Uso de `IDENTITY` vs `SERIAL` / `GENERATED`:

**SQL Server:**

```sql
CREATE TABLE Facturas (
    IdFactura INT IDENTITY(1,1) PRIMARY KEY,
    Fecha     DATETIME NOT NULL
);
```

**PostgreSQL (opción moderna):**

```sql
CREATE TABLE facturas (
    id_factura BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    fecha      TIMESTAMP NOT NULL
);
```

---

### 2. Ejemplo sencillo de conversión de tabla

**Esquema original en SQL Server:**

```sql
CREATE TABLE Ordenes (
    IdOrden          INT IDENTITY(1,1) PRIMARY KEY,
    IdCliente        UNIQUEIDENTIFIER NOT NULL,
    FechaCreacion    DATETIME NOT NULL DEFAULT GETDATE(),
    Total            MONEY NOT NULL,
    Estado           VARCHAR(20) NOT NULL
);
```

**Esquema equivalente en PostgreSQL:**

```sql
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE ordenes (
    id_orden        BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    id_cliente      UUID NOT NULL,
    fecha_creacion  TIMESTAMP NOT NULL DEFAULT NOW(),
    total           NUMERIC(19,4) NOT NULL,
    estado          VARCHAR(20) NOT NULL
);
```

---

### 3. Herramientas para migrar desde SQL Server

| Herramienta                              | Tipo           | Uso principal                                         |
|------------------------------------------|----------------|------------------------------------------------------|
| **SQL to PostgreSQL Migration Toolkit**  | Comercial      | Migración estructural y de datos desde SQL Server    |
| **pgAdmin**                              | Open source    | Importar datos vía CSV, ejecutar scripts convertidos |
| **AWS Schema Conversion Tool (SCT)**     | Gratuita (AWS) | Convertir esquemas y migrar hacia PostgreSQL         |
| **Data Migration Assistant (DMA)**       | Microsoft      | Evaluar compatibilidad y planificar migración        |
| **DBConvert / DBSync**                   | Comercial      | Migrar y sincronizar datos entre SQL Server y PG     |

Ejemplo de flujo simple con **CSV + pgAdmin / psql**:

1. En SQL Server, exportar tabla a CSV.
2. En PostgreSQL, crear tabla equivalente.
3. Importar datos:

```bash
\COPY clientes FROM '/ruta/clientes.csv' DELIMITER ',' CSV HEADER;
```

---

## C. Migración desde MySQL a PostgreSQL

### 1. Desafíos específicos

#### a) Tipos de datos incompatibles

Ejemplos comunes:

| MySQL                 | PostgreSQL                           | Comentario                                     |
|-----------------------|--------------------------------------|-----------------------------------------------|
| `TINYINT(1)`          | `BOOLEAN`                            | Muy usado como booleano en MySQL              |
| `ENUM`                | `ENUM` propio (`CREATE TYPE`) o `TEXT`/`VARCHAR` | Requiere tipo definido aparte o validación |
| `SET`                 | No directo → `TEXT` + validación     | Puede requerir modelo distinto                |
| `UNSIGNED INT`        | `INTEGER` + constraint `CHECK`       | PostgreSQL no tiene tipos `UNSIGNED`          |
| `DOUBLE`              | `DOUBLE PRECISION`                   | Similar, revisar precisión                    |

**Ejemplo: `ENUM` de MySQL**

**MySQL:**

```sql
CREATE TABLE usuarios (
    id       INT AUTO_INCREMENT PRIMARY KEY,
    nombre   VARCHAR(100),
    rol      ENUM('admin', 'editor', 'lector') NOT NULL
);
```

**PostgreSQL (opción con tipo ENUM):**

```sql
CREATE TYPE rol_enum AS ENUM ('admin', 'editor', 'lector');

CREATE TABLE usuarios (
    id      BIGSERIAL PRIMARY KEY,
    nombre  VARCHAR(100),
    rol     rol_enum NOT NULL
);
```

O bien usar `VARCHAR` + constraint:

```sql
CREATE TABLE usuarios (
    id      BIGSERIAL PRIMARY KEY,
    nombre  VARCHAR(100),
    rol     VARCHAR(20) NOT NULL CHECK (rol IN ('admin', 'editor', 'lector'))
);
```

---

#### b) Diferencias de sintaxis

Algunos ejemplos:

- Comillas invertidas en MySQL → no se usan en PG (usar comillas dobles solo si es necesario).

**MySQL:**

```sql
CREATE TABLE `producto` (
    `id` INT AUTO_INCREMENT PRIMARY KEY,
    `nombre` VARCHAR(100) NOT NULL
) ENGINE=InnoDB;
```

**PostgreSQL:**

```sql
CREATE TABLE producto (
    id      BIGSERIAL PRIMARY KEY,
    nombre  VARCHAR(100) NOT NULL
);
```

- Límites y paginación:

**MySQL:**

```sql
SELECT * FROM productos LIMIT 10 OFFSET 20;
```

**PostgreSQL:** (igual sintaxis, pero sin `SQL_CALC_FOUND_ROWS`, etc.)

```sql
SELECT * FROM productos LIMIT 10 OFFSET 20;
```

- Funciones de fecha:

| MySQL         | PostgreSQL               |
|---------------|--------------------------|
| `NOW()`       | `NOW()`                  |
| `CURDATE()`   | `CURRENT_DATE`           |
| `IFNULL(a,b)` | `COALESCE(a,b)`          |

---

### 2. Herramientas para migrar desde MySQL

| Herramienta                      | Tipo        | Uso principal                                         |
|----------------------------------|-------------|------------------------------------------------------|
| **pgLoader**                     | Open source | Migración directa MySQL → PostgreSQL (datos + esquema) |
| **AWS SCT**                      | Gratuita    | Conversión de esquemas y migración hacia PostgreSQL |
| **MySQL Workbench**              | Gratuita    | Exportar SQL/CSV que luego se adaptan a PostgreSQL  |
| **DBConvert / DBSync**           | Comercial   | Migraciones GUI entre MySQL y PostgreSQL            |

**Ejemplo básico con `pgloader`**:

Archivo de comando (`mysql_to_pg.load`):

```txt
LOAD DATABASE
     FROM mysql://usuario_mysql:pass@192.168.1.20/tienda
     INTO postgresql://usuario_pg:pass@192.168.1.30/tienda

 WITH include drop, create tables, create indexes, reset sequences

 SET work_mem to '64MB', maintenance_work_mem to '512 MB'

 CAST type enum to varchar drop typemod,
      type datetime to timestamp
;
```

Ejecución:

```bash
pgloader mysql_to_pg.load
```

---

## D. Recomendaciones Generales para Migrar a PostgreSQL

1. **Analizar primero el esquema**:
   - Identificar tipos de datos problemáticos.
   - Listar procedimientos, funciones, triggers críticos.

2. **Migrar esquema y datos por separado**:
   - Primero crear tablas e índices adaptados a PostgreSQL.
   - Luego cargar datos (pgLoader, CSV + `\COPY`, herramientas GUI, etc.).

3. **Reescribir lógica de negocio interna**:
   - Procedimientos almacenados → funciones PL/pgSQL.
   - Jobs (SQL Server Agent, eventos MySQL) → cron, pgAgent, herramientas externas.

4. **Pruebas intensivas**:
   - Comparar resultados de consultas clave antes y después.
   - Validar performance con datos reales o cercanos al volumen real.

5. **Aprovechar características nativas de PostgreSQL**:
   - Tipos `UUID`, `JSONB`, `ARRAY`, particionado, índices avanzados (GIN, BRIN).
   - Muchas veces no solo se migra, sino que **se mejora el diseño**.

Con una buena planificación y las herramientas adecuadas, la migración a PostgreSQL puede transformar un simple “cambio de motor” en una **oportunidad de optimización y modernización** de tu plataforma de datos.