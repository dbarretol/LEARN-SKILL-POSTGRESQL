# IV. Vistas y Vistas Materializadas en PostgreSQL

En esta sección se estudian dos herramientas clave para **simplificar consultas**, mejorar la **seguridad** y optimizar el **rendimiento**:

- **Vistas comunes (views)**
- **Vistas materializadas (materialized views)**

Ambas almacenan la **definición de una consulta**, pero difieren en:

- Cómo **gestionan los datos**.
- Cómo y cuándo se **actualizan**.
- Su **impacto en el rendimiento** y en el **uso de disco**.

---

## 1. Vistas Comunes (Standard Views)

Una **vista común** es una **consulta almacenada** que se comporta como una **tabla virtual**:

- **No almacena datos físicamente**.
- Solo guarda la **definición de la consulta** (el SQL).
- Cada vez que se consulta la vista, PostgreSQL ejecuta la **consulta original** sobre las tablas base.

### 1.1. Creación de una vista

```sql
CREATE VIEW vista_clientes_activos AS
SELECT id, nombre, email
FROM clientes
WHERE activo = TRUE;
```

**Uso:**

```sql
SELECT * FROM vista_clientes_activos;
```

Aquí, `vista_clientes_activos` siempre mostrará el estado actual de la tabla `clientes`.

---

### 1.2. Usos y beneficios de las vistas comunes

1. **Extracción de datos**

   Permiten encapsular una consulta y reutilizarla muchas veces:

   ```sql
   SELECT nombre, email
   FROM vista_clientes_activos
   WHERE email LIKE '%@empresa.com';
   ```

2. **Ocultamiento de complejidad**

   Puedes convertir una consulta muy larga en un acceso sencillo:

   ```sql
   CREATE VIEW vista_resumen_ventas AS
   SELECT
       c.nombre       AS cliente,
       SUM(f.total)   AS total_comprado
   FROM clientes c
   JOIN facturas f ON f.cliente_id = c.id
   GROUP BY c.nombre;
   ```

   Luego:

   ```sql
   SELECT * FROM vista_resumen_ventas
   ORDER BY total_comprado DESC;
   ```

3. **Seguridad y control de acceso**

   Puedes **exponer solo algunas columnas**:

   ```sql
   CREATE VIEW vista_clientes_publica AS
   SELECT id, nombre
   FROM clientes;

   -- Dar permisos solo sobre la vista
   GRANT SELECT ON vista_clientes_publica TO rol_lectura_publica;
   ```

   Así, el rol `rol_lectura_publica` no ve emails, teléfonos, etc.

4. **Reutilización**

   Al estar definidas y guardadas, evitan **repetir la misma consulta compleja** en múltiples partes de la aplicación.

---

### 1.3. Actualización de vistas comunes

Las vistas comunes **se actualizan automáticamente**:

- No guardan datos: siempre consultan directamente las **tablas base**.
- Si cambia un registro en la tabla base, la vista **refleja el cambio inmediatamente**.

Ejemplo:

```sql
UPDATE clientes
SET activo = FALSE
WHERE id = 10;

SELECT * FROM vista_clientes_activos
WHERE id = 10;  -- Ya no aparecerá en la vista
```

---

## 2. Vistas Materializadas (Materialized Views)

Una **vista materializada** también se define a partir de una consulta, pero a diferencia de una vista común:

- **Sí almacena físicamente los datos**.
- Guarda el **resultado** de la consulta en una estructura en disco.
- No se actualiza automáticamente cuando cambian las tablas base.

Son especialmente útiles cuando:

- Se trabaja con **consultas pesadas** (agregaciones, joins complejos).
- Se manejan **grandes volúmenes de datos**.
- Los datos **no cambian continuamente**, o se acepta tener datos algo **desfasados** (stale).

---

### 2.1. Creación de una vista materializada

```sql
CREATE MATERIALIZED VIEW mv_resumen_ventas_diario AS
SELECT
    fecha::date       AS dia,
    SUM(total)        AS total_ventas,
    COUNT(*)          AS cantidad_facturas
FROM facturas
GROUP BY fecha::date;
```

**Uso:**

```sql
SELECT * FROM mv_resumen_ventas_diario
ORDER BY dia DESC;
```

Aquí la consulta sobre `mv_resumen_ventas_diario` suele ser **mucho más rápida** que repetir el `SUM` y `COUNT` en la tabla `facturas` cada vez.

---

### 2.2. Actualización de vistas materializadas

Las vistas materializadas **no se actualizan automáticamente** cuando cambian los datos de las tablas base.  
Para que reflejen los cambios, se debe ejecutar manualmente:

```sql
REFRESH MATERIALIZED VIEW mv_resumen_ventas_diario;
```

Opcionalmente, puedes evitar que la vista quede bloqueada para lectura durante el refresco usando `CONCURRENTLY` (si tiene índice único apropiado):

```sql
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_resumen_ventas_diario;
```

> Nota: `CONCURRENTLY` tiene requisitos específicos (por ejemplo, un índice único que cubra todas las filas).

---

### 2.3. Cuándo usar vistas materializadas

Son recomendables cuando:

- Necesitas **consultas muy rápidas** sobre:
  - Datos agregados (sumas, promedios, conteos, etc.).
  - **Joins** entre tablas muy grandes.
- Los datos subyacentes:
  - Cambian **poco**.
  - O es aceptable que los usuarios vean datos “de hace unos minutos/horas”.
- Quieres **evitar cálculos repetitivos y costosos** en tiempo real.

Ejemplo típico: reportes, dashboards, informes diarios o mensuales.

---

## 3. Comparación: Vistas Comunes vs Vistas Materializadas

| Característica           | Vistas Comunes                             | Vistas Materializadas                                  |
|--------------------------|--------------------------------------------|--------------------------------------------------------|
| **Almacenamiento físico**| No almacenan datos (solo la definición).  | **Sí almacenan** los datos de la consulta.            |
| **Uso de disco**         | Prácticamente nulo (solo metadatos).      | **Sí usan disco**, proporcional al resultado.         |
| **Actualización de datos** | Automática (siempre consulta tablas base).| **Manual** con `REFRESH MATERIALIZED VIEW`.           |
| **Frescura de la información** | Siempre al día.                    | Puede estar desfasada hasta el último `REFRESH`.      |
| **Velocidad de consulta**| Depende de las tablas y la consulta.      | Generalmente **más rápida** (datos precalculados).    |
| **Coste de mantenimiento**| Bajo.                                    | Mayor: requiere planificar y ejecutar refrescos.      |
| **Uso típico**           | Simplificación, seguridad, reutilización. | Reportes, analítica, consultas pesadas recurrentes.   |

---

## 4. Ejemplo Comparativo Completo

### 4.1. Vista común para simplificar consultas

```sql
CREATE VIEW vista_ordenes_cliente AS
SELECT
    c.id          AS cliente_id,
    c.nombre      AS cliente,
    o.id          AS orden_id,
    o.fecha,
    o.total
FROM clientes c
JOIN ordenes o ON o.cliente_id = c.id;
```

**Uso:**

```sql
SELECT *
FROM vista_ordenes_cliente
WHERE cliente_id = 1
ORDER BY fecha DESC;
```

- Siempre refleja el estado actual de `clientes` y `ordenes`.
- Buena para el día a día de la aplicación.

---

### 4.2. Vista materializada para reportes agregados

```sql
CREATE MATERIALIZED VIEW mv_ventas_por_cliente AS
SELECT
    c.id        AS cliente_id,
    c.nombre    AS cliente,
    SUM(o.total) AS total_comprado,
    COUNT(o.id) AS cantidad_ordenes
FROM clientes c
JOIN ordenes o ON o.cliente_id = c.id
GROUP BY c.id, c.nombre;
```

**Uso:**

```sql
SELECT *
FROM mv_ventas_por_cliente
ORDER BY total_comprado DESC
LIMIT 10;
```

**Refresco periódico (por ejemplo, cada noche):**

```sql
REFRESH MATERIALIZED VIEW mv_ventas_por_cliente;
```

- La consulta sobre `mv_ventas_por_cliente` será mucho más rápida.
- Ideal para informes y paneles de control.

---

## 5. Resumen

- **Vistas comunes**
  - Son **tablas virtuales** basadas en una consulta.
  - No almacenan datos; siempre se actualizan automáticamente.
  - Útiles para:
    - Simplificar consultas.
    - Aplicar seguridad a nivel de columnas/filas.
    - Reutilizar lógica de consulta.

- **Vistas materializadas**
  - Almacenan el **resultado** de una consulta en disco.
  - Requieren **refrescos manuales** con `REFRESH MATERIALIZED VIEW`.
  - Ideales para:
    - Consultas pesadas y repetitivas.
    - Escenarios de reporte y analítica.

Elegir entre una u otra dependerá del equilibrio que necesites entre:

- **Frescura de los datos**  
- **Rendimiento de las consultas**  
- **Coste de mantenimiento y espacio en disco**