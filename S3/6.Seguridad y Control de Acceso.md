# VI. Seguridad y Control de Acceso en PostgreSQL

La **seguridad** en PostgreSQL se basa principalmente en:

- **Roles y permisos** (quién puede hacer qué).
- **Seguridad de conexión y encriptación** (cómo se conectan y autentican los usuarios).

---

## 1. Roles y Permisos

PostgreSQL utiliza **roles** para gestionar usuarios y grupos de permisos.  
Un rol puede:

- Representar a un **usuario** (con `LOGIN`).
- Representar a un **grupo de permisos** (sin `LOGIN`).

### 1.1. Creación de usuarios y roles

#### 1.1.1. Crear un rol de solo lectura (sin login)

```sql
CREATE ROLE rol_lectura;
```

#### 1.1.2. Crear un usuario (rol con login)

```sql
CREATE ROLE usuario_reportes
    LOGIN
    PASSWORD 'C0ntr4s3ñ4Segura';
```

#### 1.1.3. Asignar rol a usuario

```sql
GRANT rol_lectura TO usuario_reportes;
```

#### 1.1.4. Cambiar la contraseña de un usuario

```sql
ALTER ROLE usuario_reportes
    PASSWORD 'NuevaC0ntr4s3ñ4';
```

#### 1.1.5. Eliminar un rol

```sql
DROP ROLE rol_lectura;
```

---

### 1.2. Niveles de control de acceso

PostgreSQL permite un control de acceso muy granular:

- A nivel de **base de datos**.
- A nivel de **esquema**.
- A nivel de **tabla**.
- A nivel de **columna**.
- A nivel de **función**, **secuencia** y otros objetos.

#### 1.2.1. Privilegios comunes

| Objeto   | Privilegios típicos                          |
|----------|----------------------------------------------|
| Base de datos | `CONNECT`, `CREATE`, `TEMP`           |
| Tabla    | `SELECT`, `INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`, `REFERENCES` |
| Columna  | `SELECT`, `UPDATE`, `INSERT`                |
| Función  | `EXECUTE`                                   |

#### 1.2.2. Ejemplo: otorgar y revocar permisos sobre una tabla

```sql
-- Otorgar solo lectura sobre una tabla
GRANT SELECT ON productos TO rol_lectura;

-- Otorgar permiso de inserción y actualización
GRANT INSERT, UPDATE ON productos TO usuario_reportes;

-- Revocar permisos
REVOKE UPDATE ON productos FROM usuario_reportes;
```

#### 1.2.3. Ejemplo: restringir columnas sensibles

Supongamos una tabla con datos sensibles:

```sql
CREATE TABLE empleados (
    id          SERIAL PRIMARY KEY,
    nombre      TEXT NOT NULL,
    salario     NUMERIC(10,2),
    documento   TEXT
);
```

Podemos otorgar **lectura solo sobre ciertas columnas**:

```sql
-- Permitir ver solo id y nombre
GRANT SELECT (id, nombre) ON empleados TO rol_lectura;
```

Los usuarios con `rol_lectura` no podrán consultar `salario` ni `documento`.

---

## 2. Seguridad de Conexiones y Encriptación

Además de los permisos internos, es fundamental proteger:

- **Cómo se conectan los usuarios**.
- **Cómo se autentican**.
- **Si la conexión va cifrada**.

### 2.1. Métodos de autenticación (`pg_hba.conf`)

El archivo `pg_hba.conf` define desde dónde y cómo se puede conectar cada usuario.  
Ejemplo de entrada típica:

```text
# Tipo  BD        Usuario           Dirección        Método
host    mi_base   usuario_reportes  192.168.1.0/24   scram-sha-256
```

Métodos de autenticación comunes:

- `md5` / `scram-sha-256`: contraseña cifrada (recomendado).
- `trust`: sin contraseña (no recomendado salvo entornos controlados).
- `peer`, `ident`, `gss`, etc. (según integración).

---

### 2.2. Cifrado de conexión (SSL/TLS)

PostgreSQL soporta **conexiones cifradas** mediante SSL/TLS:

- Protege los datos en tránsito entre cliente y servidor.
- Requiere configurar certificados en el servidor.

Fragmento típico en `postgresql.conf`:

```text
ssl = on
ssl_cert_file = 'server.crt'
ssl_key_file  = 'server.key'
```

En el cliente (por ejemplo, `psql`):

```bash
psql "host=mi-servidor dbname=mi_base user=usuario_reportes sslmode=require"
```

`sslmode=require` fuerza el uso de una conexión cifrada.

---

# VII. Ejemplos de Consultas SQL Avanzadas

En la gestión avanzada de bases de datos, son frecuentes:

- **Consultas de agregación** (`SUM`, `AVG`, `COUNT`, etc.).
- **Subconsultas** (consultas anidadas dentro de otras).
- Combinación de ambas para análisis más profundos.

A continuación se muestran ejemplos prácticos para reforzar comprensión y uso.

---

## 1. Consultas de Agregación

Las consultas de agregación se emplean para:

- Obtener **totales**, **promedios**, **conteos**.
- Resumir información por **grupo** (`GROUP BY`).

Supongamos las tablas:

```sql
CREATE TABLE categorias (
    id          SERIAL PRIMARY KEY,
    nombre      TEXT NOT NULL
);

CREATE TABLE productos (
    id              SERIAL PRIMARY KEY,
    nombre          TEXT NOT NULL,
    precio          NUMERIC(10,2) NOT NULL,
    categoria_id    INTEGER REFERENCES categorias(id)
);
```

### 1.1. Suma de productos por categoría

**Objetivo:** sumar el precio total de los productos por categoría.

```sql
SELECT
    c.nombre                    AS categoria,
    SUM(p.precio)               AS total,
    COUNT(p.id)                 AS cantidad_productos
FROM categorias c
JOIN productos p
    ON p.categoria_id = c.id
GROUP BY c.nombre
ORDER BY total DESC;
```

Puntos clave:

- `SUM(p.precio)` calcula el **importe total**.
- `COUNT(p.id)` cuenta los productos por categoría.
- `GROUP BY c.nombre` agrupa por categoría.
- `ORDER BY total DESC` ordena de mayor a menor total.

### 1.2. Filtro sobre agregados: `HAVING`

**Objetivo:** mostrar solo categorías con un total mayor a 10,000.

```sql
SELECT
    c.nombre        AS categoria,
    SUM(p.precio)   AS total
FROM categorias c
JOIN productos p
    ON p.categoria_id = c.id
GROUP BY c.nombre
HAVING SUM(p.precio) > 10000
ORDER BY total DESC;
```

- `HAVING` se usa para filtrar **después** de agrupar.

---

## 2. Subconsultas (Subqueries)

Una **subconsulta** es una consulta anidada dentro de otra.  
Se utilizan para:

- Calcular valores que luego se usan como condición.
- Seleccionar subconjuntos de datos.
- Verificar existencias (`EXISTS`), pertenencia (`IN`), etc.

### 2.1. Productos con precio mayor al promedio

**Objetivo:** obtener productos cuyo precio es **mayor al precio promedio** de todos los productos.

```sql
SELECT
    nombre,
    precio
FROM productos
WHERE precio > (
    SELECT AVG(precio)
    FROM productos
);
```

Explicación:

- La subconsulta `SELECT AVG(precio) FROM productos` calcula el **precio promedio**.
- La consulta externa devuelve solo los productos con `precio` superior a ese valor.

---

### 2.2. Productos en categorías con un mínimo de productos

**Objetivo:** listar productos que pertenecen a categorías con **al menos 5 productos**.

```sql
SELECT
    p.nombre,
    p.precio,
    c.nombre AS categoria
FROM productos p
JOIN categorias c
    ON p.categoria_id = c.id
WHERE c.id IN (
    SELECT categoria_id
    FROM productos
    GROUP BY categoria_id
    HAVING COUNT(*) >= 5
);
```

- La subconsulta en `IN` obtiene los `categoria_id` con 5 o más productos.
- La consulta externa muestra solo los productos que pertenecen a esas categorías.

---

### 2.3. Uso de `EXISTS` para verificar existencia relacionada

**Objetivo:** obtener categorías que tengan al menos un producto con precio mayor a 1,000.

```sql
SELECT
    c.id,
    c.nombre
FROM categorias c
WHERE EXISTS (
    SELECT 1
    FROM productos p
    WHERE p.categoria_id = c.id
      AND p.precio > 1000
);
```

- `EXISTS` verifica si la subconsulta devuelve **al menos una fila**.
- Es eficiente cuando solo importa la **existencia**, no el detalle.

---

## 3. Resumen

- La **seguridad en PostgreSQL** se funda en:
  - Gestión correcta de **roles y permisos**.
  - Definición adecuada de **métodos de autenticación** y **conexiones cifradas**.
- Las **consultas avanzadas**:
  - Usan **agregaciones** para obtener resúmenes de datos.
  - Usan **subconsultas** para comparar, filtrar y analizar información con mayor precisión.

Dominar estos conceptos permite:

- Diseñar sistemas más **seguros**.
- Escribir consultas más **expresivas** y **potentes** para la toma de decisiones.