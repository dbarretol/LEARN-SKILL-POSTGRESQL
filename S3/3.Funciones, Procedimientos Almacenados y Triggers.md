# III. Funciones, Procedimientos Almacenados y Triggers en PostgreSQL

En esta sección se presentan los mecanismos avanzados que permiten incorporar **lógica de programación** directamente en PostgreSQL:

- **Funciones** (principalmente con PL/pgSQL)
- **Procedimientos almacenados**
- **Triggers** (disparadores)

Estos elementos son clave para la **automatización**, la **integridad operacional** y la **implementación de reglas de negocio** dentro de la base de datos.

---

## 1. Funciones en PL/pgSQL

PostgreSQL permite crear **funciones almacenadas** utilizando el lenguaje de procedimientos **PL/pgSQL** (*Procedural Language PostgreSQL*).

Con PL/pgSQL puedes:

- Escribir **lógica compleja** cercana a los datos.
- Usar **estructuras de control**:
  - Condicionales (`IF`, `ELSIF`, `ELSE`)
  - Bucles (`LOOP`, `WHILE`, `FOR`)
- Manejar **excepciones** (`EXCEPTION`).
- Combinar **SQL + lógica procedural**.

---

### 1.1. Estructura básica de una función

Puntos clave al declarar una función:

1. **Inicialización y parámetros**

   ```sql
   CREATE FUNCTION nombre_funcion(param1 tipo1, param2 tipo2, ...)
   ```

2. **Tipo de retorno**

   ```sql
   RETURNS tipo_retorno
   ```

   Ejemplos de tipo de retorno:
   - `integer`, `numeric`, `text`, `boolean`, `date`, etc.
   - `void` (cuando no se devuelve nada)
   - Filas (`RETURNS TABLE(...)`)
   - Tipos compuestos.

3. **Lenguaje y cuerpo**

   ```sql
   LANGUAGE plpgsql
   AS $$
   DECLARE
       -- Declaración de variables locales (opcional)
   BEGIN
       -- Lógica de la función
       RETURN ...;
   END;
   $$;
   ```

   - El cuerpo se delimita normalmente con `$$ ... $$`.
   - La lógica se encuentra entre `BEGIN` y `END;`.
   - Se usa `RETURN` para devolver resultados.

---

### 1.2. Ejemplo: función que suma dos números

```sql
CREATE FUNCTION sumar(a integer, b integer)
RETURNS integer
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN a + b;
END;
$$;
```

**Uso:**

```sql
SELECT sumar(10, 5);  -- Resultado: 15
```

---

### 1.3. Ejemplo: función con lógica condicional

```sql
CREATE FUNCTION clasificar_edad(edad integer)
RETURNS text
LANGUAGE plpgsql
AS $$
BEGIN
    IF edad < 18 THEN
        RETURN 'Menor de edad';
    ELSIF edad < 65 THEN
        RETURN 'Adulto';
    ELSE
        RETURN 'Adulto mayor';
    END IF;
END;
$$;
```

**Uso:**

```sql
SELECT clasificar_edad(20);   -- 'Adulto'
SELECT clasificar_edad(70);   -- 'Adulto mayor'
```

---

### 1.4. Ejemplo: función que devuelve un conjunto de filas

```sql
CREATE FUNCTION productos_con_stock_minimo(min_stock integer)
RETURNS TABLE(id integer, nombre text, stock integer)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT p.id, p.nombre, p.stock
    FROM productos p
    WHERE p.stock >= min_stock;
END;
$$;
```

**Uso:**

```sql
SELECT * FROM productos_con_stock_minimo(10);
```

---

## 2. Procedimientos Almacenados

Los **procedimientos almacenados** (definidos con `CREATE PROCEDURE`) permiten ejecutar lógica en la base de datos similar a las funciones, pero con características específicas:

- Se invocan con `CALL`, no con `SELECT`.
- No retornan un valor directamente mediante `RETURN`.
- Pueden realizar **control explícito de transacciones** (`COMMIT`, `ROLLBACK`) dentro de su cuerpo.

---

### 2.1. Estructura básica de un procedimiento

```sql
CREATE PROCEDURE nombre_procedimiento(param1 tipo1, param2 tipo2, ...)
LANGUAGE plpgsql
AS $$
BEGIN
    -- Lógica del procedimiento
    -- Aquí se pueden hacer INSERT, UPDATE, DELETE, etc.
END;
$$;
```

**Invocación:**

```sql
CALL nombre_procedimiento(valor1, valor2, ...);
```

---

### 2.2. Ejemplo: procedimiento con control de transacción

```sql
CREATE PROCEDURE transferir_monto(
    p_cuenta_origen integer,
    p_cuenta_destino integer,
    p_monto numeric
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- Iniciamos un bloque de transacción explícitamente
    START TRANSACTION;

    UPDATE cuentas
    SET saldo = saldo - p_monto
    WHERE id = p_cuenta_origen;

    UPDATE cuentas
    SET saldo = saldo + p_monto
    WHERE id = p_cuenta_destino;

    -- Aquí podríamos agregar validaciones y lanzar excepciones

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
$$;
```

**Uso:**

```sql
CALL transferir_monto(1, 2, 250.00);
```

---

## 3. Diferencias clave entre Funciones y Procedimientos

| Característica          | Función                                      | Procedimiento almacenado                         |
|-------------------------|----------------------------------------------|--------------------------------------------------|
| **Definición**          | `CREATE FUNCTION`                            | `CREATE PROCEDURE`                               |
| **Invocación**          | Mediante `SELECT` o en expresiones SQL      | Mediante `CALL`                                  |
| **Retorno de valor**    | Devuelve valor con `RETURN` (escalar o filas)| No devuelve valor directo con `RETURN`          |
| **Uso en consultas**    | Puede usarse en `SELECT`, `WHERE`, `JOIN`, etc.| No se usa dentro de consultas SQL              |
| **Control de transacción** | No puede hacer `COMMIT`/`ROLLBACK` internos | Puede hacer `COMMIT` y `ROLLBACK` dentro        |
| **Parámetros**          | Habitualmente de entrada; puede tener `OUT` | Puede tener parámetros `IN`, `OUT`, `INOUT`     |

> Nota: Tanto funciones como procedimientos pueden ejecutar **consultas SQL** dentro de su cuerpo (`SELECT`, `INSERT`, `UPDATE`, `DELETE`, etc.).

---

## 4. Triggers (Disparadores)

Un **trigger** es un mecanismo que permite **ejecutar automáticamente** una función cuando ocurre un evento sobre una tabla o vista.

- Se asocia a una tabla o vista.
- Se dispara **antes** o **después** de ciertos eventos:
  - `INSERT`
  - `UPDATE`
  - `DELETE`
  - `TRUNCATE` (en algunos casos)

---

### 4.1. Tipos de triggers

- **Por fila** (`FOR EACH ROW`)
  - Se ejecuta **una vez por cada fila afectada**.
  - Permite acceder a los registros:
    - `NEW` (nuevo valor)
    - `OLD` (valor antiguo)

- **Por sentencia** (`FOR EACH STATEMENT`)
  - Se ejecuta **una vez por sentencia**, sin importar cuántas filas se afecten.

---

### 4.2. Ejemplo completo: trigger de auditoría

**1. Tabla principal y tabla de auditoría**

```sql
CREATE TABLE empleados (
    id          SERIAL PRIMARY KEY,
    nombre      text NOT NULL,
    salario     numeric(10,2) NOT NULL
);

CREATE TABLE empleados_auditoria (
    id              SERIAL PRIMARY KEY,
    empleado_id     integer,
    operacion       text,
    salario_anterior numeric(10,2),
    salario_nuevo    numeric(10,2),
    fecha           timestamp NOT NULL DEFAULT NOW()
);
```

**2. Función de trigger**

```sql
CREATE FUNCTION auditar_cambios_salario()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        INSERT INTO empleados_auditoria (
            empleado_id,
            operacion,
            salario_anterior,
            salario_nuevo
        )
        VALUES (
            OLD.id,
            TG_OP,              -- 'UPDATE'
            OLD.salario,
            NEW.salario
        );
    END IF;

    -- Devolvemos NEW para confirmar el cambio
    RETURN NEW;
END;
$$;
```

**3. Creación del trigger**

```sql
CREATE TRIGGER trg_auditar_salario
AFTER UPDATE OF salario
ON empleados
FOR EACH ROW
EXECUTE FUNCTION auditar_cambios_salario();
```

**4. Uso**

```sql
UPDATE empleados
SET salario = salario + 500
WHERE id = 1;

SELECT * FROM empleados_auditoria
ORDER BY fecha DESC;
```

El trigger se encargará automáticamente de registrar cada cambio de salario.

---

## 5. Resumen

- **Funciones (PL/pgSQL)**  
  - Permiten encapsular lógica compleja.
  - Se usan en consultas y devuelven valores.
- **Procedimientos almacenados**  
  - Se ejecutan con `CALL`.
  - Permiten control explícito de transacciones.
- **Triggers (disparadores)**  
  - Ejecutan funciones automáticamente ante eventos (`INSERT`, `UPDATE`, `DELETE`, `TRUNCATE`).
  - Son ideales para auditoría, validaciones automáticas y reglas de negocio.

Estos mecanismos permiten llevar la **lógica de negocio** directamente al servidor de bases de datos, mejorando la **consistencia**, la **seguridad** y la **automatización** de los procesos.