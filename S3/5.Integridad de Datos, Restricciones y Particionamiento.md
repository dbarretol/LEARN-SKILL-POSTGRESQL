# V. Integridad de Datos, Restricciones y Particionamiento en PostgreSQL

En esta sección se abordan técnicas avanzadas para:

- Garantizar la **coherencia e integridad** de los datos.
- **Inspeccionar y verificar restricciones** (constraints) existentes.
- Gestionar **grandes volúmenes de información** mediante **particionamiento de tablas**.

---

## 1. Integridad de Datos

La **integridad de datos** se refiere a la **consistencia y coherencia** de la información almacenada, especialmente en las **relaciones entre tablas**.

Ejemplo típico: si la tabla `usuarios` se relaciona 1 a 1 con la tabla `clientes`, se espera que:

- Cada registro en `usuarios` tenga su correspondiente registro en `clientes`.
- El número de registros relacionados sea coherente con la lógica de negocio.

---

### 1.1. Verificación básica con recuento de registros

```sql
SELECT
    (SELECT COUNT(*) FROM usuarios) AS total_usuarios,
    (SELECT COUNT(*) FROM clientes) AS total_clientes;
```

Si por regla de negocio cada usuario debe tener un cliente asociado, los valores deberían coincidir.

---

### 1.2. Detección de posibles inconsistencias

**Usuarios sin cliente asociado:**

```sql
SELECT u.*
FROM usuarios u
LEFT JOIN clientes c ON c.usuario_id = u.id
WHERE c.id IS NULL;
```

**Clientes sin usuario asociado:**

```sql
SELECT c.*
FROM clientes c
LEFT JOIN usuarios u ON u.id = c.usuario_id
WHERE u.id IS NULL;
```

Estos patrones ayudan a detectar posibles **fallos de integridad referencial**, especialmente cuando no se han definido correctamente las **claves foráneas**.

---

## 2. Verificación de Restricciones (Constraints)

Las **restricciones** son reglas que PostgreSQL aplica para garantizar la validez de los datos.

### 2.1. Tipos comunes de restricciones

| Tipo de restricción | Descripción                                               |
|---------------------|-----------------------------------------------------------|
| `PRIMARY KEY`       | Identifica un registro de forma única y no nula.         |
| `FOREIGN KEY`       | Enlaza una columna con la clave primaria de otra tabla.  |
| `UNIQUE`            | Evita valores duplicados en una o varias columnas.       |
| `CHECK`             | Valida una condición lógica sobre los datos.             |
| `NOT NULL`          | Obliga a que la columna tenga siempre un valor.          |

Ejemplo de creación de tabla con restricciones:

```sql
CREATE TABLE clientes (
    id          SERIAL PRIMARY KEY,
    usuario_id  INTEGER NOT NULL UNIQUE,
    nombre      TEXT NOT NULL,
    email       TEXT UNIQUE,
    edad        INTEGER CHECK (edad >= 18),
    CONSTRAINT fk_clientes_usuarios
        FOREIGN KEY (usuario_id)
        REFERENCES usuarios(id)
);
```

---

### 2.2. Consultar restricciones en `information_schema`

PostgreSQL ofrece vistas en el esquema `information_schema` para **inspeccionar restricciones** sin conocer los detalles internos del sistema.

#### 2.2.1. Listar restricciones de una tabla

```sql
SELECT
    tc.constraint_name,
    tc.constraint_type,
    tc.table_name
FROM information_schema.table_constraints tc
WHERE tc.table_schema = 'public'
  AND tc.table_name   = 'clientes';
```

#### 2.2.2. Ver detalles de claves foráneas (tabla padre/hija y columnas)

Ejemplo: obtener información de todas las **claves foráneas** del esquema `public`:

```sql
SELECT
    tc.constraint_name,
    tc.table_name           AS tabla_hija,
    kcu.column_name         AS columna_hija,
    ccu.table_name          AS tabla_padre,
    ccu.column_name         AS columna_padre
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
   AND tc.table_schema   = kcu.table_schema
JOIN information_schema.constraint_column_usage ccu
    ON ccu.constraint_name = tc.constraint_name
   AND ccu.table_schema   = tc.table_schema
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_schema    = 'public'
ORDER BY tabla_hija, constraint_name;
```

Con esta consulta puedes:

- Ver qué tablas dependen de otras (relaciones padre/hija).
- Identificar las columnas involucradas en las **claves foráneas**.
- Auditar si las relaciones están definidas como lo exige la lógica de negocio.

---

## 3. Particionamiento de Tablas

El **particionamiento** consiste en dividir una tabla lógica grande en **múltiples partes físicas** llamadas *particiones*, manteniendo la visión de una sola tabla desde el punto de vista del usuario.

Es especialmente útil cuando una tabla supera varios **millones de registros** (por ejemplo, más de 3–4 millones).

### 3.1. Beneficios del particionamiento

- **Mejor rendimiento** en:
  - Búsquedas filtradas por la columna de particionamiento (por ejemplo, por fecha).
  - Operaciones de borrado masivo (archivar datos antiguos).
- **Mantenimiento más sencillo**:
  - Eliminar datos antiguos con `DROP TABLE` sobre una partición.
- **Mejor gestión de espacio**:
  - Permite usar diferentes estrategias de almacenamiento por partición.

---

### 3.2. Estrategias de particionamiento

PostgreSQL soporta varias estrategias:

| Estrategia              | Cláusula                | Uso típico                             |
|-------------------------|-------------------------|----------------------------------------|
| Por rango               | `PARTITION BY RANGE`    | Fechas, rangos numéricos (años, meses)|
| Por lista               | `PARTITION BY LIST`     | Valores discretos (país, región, etc.)|
| Por hash                | `PARTITION BY HASH`     | Distribución uniforme de carga         |

En esta sección nos centraremos en el **particionamiento por rango**.

---

### 3.3. Particionamiento por rango (ejemplo con fechas)

Supongamos que tenemos una tabla de `ventas` con millones de registros, y queremos particionar por **mes**.

#### 3.3.1. Crear la tabla principal particionada

```sql
CREATE TABLE ventas (
    id          BIGSERIAL PRIMARY KEY,
    fecha       DATE NOT NULL,
    cliente_id  INTEGER NOT NULL,
    total       NUMERIC(12,2) NOT NULL
)
PARTITION BY RANGE (fecha);
```

Esta tabla no almacenará datos directamente; los datos se guardan en sus **particiones hijas**.

---

#### 3.3.2. Crear particiones por mes

```sql
-- Ventas de enero 2023
CREATE TABLE ventas_2023_01
PARTITION OF ventas
FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');

-- Ventas de febrero 2023
CREATE TABLE ventas_2023_02
PARTITION OF ventas
FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');
```

Puedes repetir este patrón para cada mes o periodo que necesites.

---

#### 3.3.3. Inserciones y consultas con particiones

Desde el punto de vista del usuario, se sigue trabajando sobre la tabla **principal**:

```sql
-- Inserción (PostgreSQL decide en qué partición guardar el dato)
INSERT INTO ventas (fecha, cliente_id, total)
VALUES ('2023-01-15', 10, 150.00);

INSERT INTO ventas (fecha, cliente_id, total)
VALUES ('2023-02-20', 20, 300.00);

-- Consulta: PostgreSQL solo accederá a las particiones relevantes
SELECT *
FROM ventas
WHERE fecha BETWEEN '2023-02-01' AND '2023-02-28';
```

PostgreSQL utilizará **pruning de particiones** (ignorará particiones fuera del rango de fechas solicitado), mejorando el rendimiento.

---

### 3.4. Manejo y mantenimiento de particiones

#### 3.4.1. Crear particiones futuras

Puedes crear particiones por adelantado:

```sql
-- Partición para marzo 2023
CREATE TABLE ventas_2023_03
PARTITION OF ventas
FOR VALUES FROM ('2023-03-01') TO ('2023-04-01');
```

#### 3.4.2. Eliminar datos antiguos de forma eficiente

Si ya no necesitas datos del año 2022, basta con eliminar la partición:

```sql
DROP TABLE ventas_2022_01;
DROP TABLE ventas_2022_02;
-- etc.
```

Esto es mucho más rápido que ejecutar un `DELETE` sobre millones de filas.

---

### 3.5. Particionamiento dinámico (idea general)

En escenarios avanzados, es posible:

- Crear una **función** que cree automáticamente nuevas particiones (por ejemplo, cada mes).
- Programar su ejecución mediante un **job** externo (cron, pgAgent, etc.).

Ejemplo simplificado de función (solo ilustrativo):

```sql
CREATE OR REPLACE FUNCTION crear_particion_ventas_mes(p_anio integer, p_mes integer)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
    fecha_inicio DATE;
    fecha_fin    DATE;
    nombre_particion text;
BEGIN
    fecha_inicio := make_date(p_anio, p_mes, 1);
    fecha_fin    := (fecha_inicio + INTERVAL '1 month')::date;
    nombre_particion := format('ventas_%s_%s', p_anio, lpad(p_mes::text, 2, '0'));

    EXECUTE format(
        'CREATE TABLE IF NOT EXISTS %I PARTITION OF ventas
         FOR VALUES FROM (%L) TO (%L);',
        nombre_particion,
        fecha_inicio,
        fecha_fin
    );
END;
$$;
```

Uso:

```sql
SELECT crear_particion_ventas_mes(2023, 4);  -- Crea ventas_2023_04 si no existe
```

---

## 6. Resumen

- La **integridad de datos** garantiza la **coherencia** entre tablas y registros relacionados.
- Las **restricciones (constraints)**:
  - Impiden datos inválidos.
  - Se pueden auditar usando `information_schema`.
- El **particionamiento de tablas**:
  - Divide grandes tablas en partes manejables.
  - Mejora el rendimiento en consultas y mantenimiento.
  - Es especialmente útil para tablas muy grandes, como logs o ventas históricas.

Aplicar correctamente estas técnicas permite que bases de datos PostgreSQL sean más:

- **Confiables**
- **Escalables**
- **Fáciles de mantener**