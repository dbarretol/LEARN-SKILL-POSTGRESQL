# I. Introducción a Funcionalidades Avanzadas de PostgreSQL

En esta sección iniciamos el estudio de las **capacidades avanzadas de PostgreSQL**, centrándonos en los mecanismos fundamentales para asegurar la **integridad** y la **ejecución correcta** de las operaciones en el sistema de gestión de bases de datos.

---

## 1. Contexto del Curso

Esta explicación corresponde a la **tercera sesión** del curso de **gestión de bases de datos PostgreSQL**, momento en el que se comienza a explorar las **funcionalidades avanzadas** del motor, entre ellas:

- Manejo de **transacciones**.
- **Control de concurrencia**.
- Aseguramiento de la **consistencia** de los datos ante múltiples usuarios.

---

## 2. ¿Por qué son necesarias las transacciones y el control de concurrencia?

Para garantizar que las operaciones sobre la base de datos se ejecuten de forma **correcta, segura y consistente**, es fundamental:

- Utilizar **transacciones**.
- Implementar un adecuado **control de concurrencia** (cuando varios usuarios acceden y modifican datos al mismo tiempo).

Sin estos mecanismos:

- Se pueden generar **inconsistencias** en los datos.
- Algunas operaciones pueden quedar **a medias**.
- Se pierde la **confiabilidad** de la base de datos.

---

## 3. ¿Qué es una transacción en PostgreSQL?

Una **transacción** es un **conjunto de operaciones** que se ejecutan como una **unidad lógica indivisible**.  
Es especialmente importante en operaciones como:

- **Inserción** de datos (`INSERT`)
- **Consulta** de datos (`SELECT`)
- **Actualización** de datos (`UPDATE`)
- **Eliminación** de datos (`DELETE`)

### 3.1. Ciclo básico de una transacción

En PostgreSQL, el flujo típico de una transacción es:

1. Iniciar la transacción.
2. Ejecutar una o varias operaciones SQL.
3. Confirmar los cambios o deshacerlos.

Ejemplo básico:

```sql
-- Iniciar una transacción
BEGIN;

-- Operaciones dentro de la transacción
INSERT INTO clientes (nombre, email)
VALUES ('Ana Pérez', 'ana.perez@example.com');

UPDATE cuentas
SET saldo = saldo - 100
WHERE id = 1;

UPDATE cuentas
SET saldo = saldo + 100
WHERE id = 2;

-- Confirmar todas las operaciones
COMMIT;
```

En este ejemplo, todas las operaciones (inserción y actualizaciones) forman parte de **una sola transacción**.

---

## 4. Atomicidad: el principio de “todo o nada”

La característica clave de una transacción es que debe cumplir el principio de **atomicidad**.

> **Atomicidad**:  
> Todas las operaciones dentro de una transacción se ejecutan **completamente** o **no se ejecuta ninguna**.  
> No se permiten resultados “a medias”.

Si alguna operación falla:

- La base de datos **revierte** todos los cambios realizados dentro de esa transacción.
- El estado de la base de datos vuelve a ser el **estado original** anterior al inicio de la transacción.

### 4.1. Ejemplo con error y uso de ROLLBACK

```sql
BEGIN;

-- Primera operación
UPDATE cuentas
SET saldo = saldo - 500
WHERE id = 1;

-- Segunda operación (supongamos que aquí ocurre un error, por ejemplo, id inexistente)
UPDATE cuentas
SET saldo = saldo + 500
WHERE id = 9999;  -- No existe esta cuenta

-- Como hubo un error, decidimos deshacer toda la transacción
ROLLBACK;
```

Resultado:

- Ninguno de los cambios se aplica de forma permanente.
- El saldo de la cuenta con `id = 1` **no se modifica**, gracias a la atomicidad.

### 4.2. COMMIT vs ROLLBACK

| Comando    | Descripción                                           |
|-----------|--------------------------------------------------------|
| `COMMIT`  | Confirma la transacción; los cambios se vuelven definitivos. |
| `ROLLBACK`| Deshace la transacción; los cambios se descartan.      |

---

## 5. Importancia del control de concurrencia

Cuando varios usuarios o procesos acceden y modifican la base de datos al mismo tiempo, se habla de **concurrencia**.  
Sin un control adecuado, pueden ocurrir problemas como:

- **Lecturas sucias** (leer datos no confirmados por otra transacción).
- **Actualizaciones perdidas** (una actualización sobrescribe otra).
- **Lecturas inconsistentes** (ver estados intermedios de los datos).

PostgreSQL utiliza mecanismos internos (como **MVCC – Multi-Version Concurrency Control**) para:

- Permitir que múltiples transacciones trabajen al mismo tiempo.
- Mantener la **consistencia** y **aislamiento** de los datos.
- Evitar que una transacción vea datos **a medio modificar** por otra.

### 5.1. Ejemplo sencillo de concurrencia

Imagina dos usuarios ejecutando transacciones casi al mismo tiempo:

```sql
-- Transacción A
BEGIN;
UPDATE productos
SET stock = stock - 1
WHERE id = 10;

-- (Aún no hace COMMIT)

-- Transacción B
BEGIN;
SELECT stock
FROM productos
WHERE id = 10;
-- PostgreSQL decide qué versión de los datos muestra a B,
-- según el nivel de aislamiento configurado.

COMMIT;
```

Aquí, el **control de concurrencia** de PostgreSQL determinará:

- Si B ve el stock **antes** o **después** de la actualización de A.
- Si B puede leer un estado **consistente** sin datos intermedios.

---

## 6. Resumen

- Una **transacción** es un conjunto de operaciones tratadas como una **unidad indivisible**.
- La **atomicidad** garantiza el principio de **“todo o nada”**.
- El **uso de transacciones** es esencial para mantener la **fiabilidad** y **estabilidad** de las tablas.
- El **control de concurrencia** asegura que múltiples usuarios puedan trabajar simultáneamente sobre la base de datos sin comprometer la **integridad** de la información.

Estas bases son el punto de partida para profundizar en otras funcionalidades avanzadas de PostgreSQL, como niveles de aislamiento, bloqueos (locks) y estrategias de optimización de concurrencia.