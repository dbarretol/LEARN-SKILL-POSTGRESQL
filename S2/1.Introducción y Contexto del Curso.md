# I. Introducción y contexto del curso

## 1. Enfoque del curso: SQL y PostgreSQL

Este curso se centra en la gestión de bases de datos relacionales utilizando **SQL** sobre **PostgreSQL**.  
Corresponde a la **segunda clase del módulo**, donde se profundiza en:

- **Modelado de datos** (normalización y desnormalización).
- **Consultas avanzadas** (JOINs, CTEs, funciones de ventana, optimización).

Todo el contenido se ejemplifica con implementaciones específicas de **PostgreSQL**, trabajando sobre un esquema de ejemplo, por ejemplo: `tienda`.

---

## 2. PostgreSQL como motor principal

A lo largo del curso se utiliza PostgreSQL para:

- Crear y modificar esquemas y tablas.
- Definir **claves primarias** y **claves foráneas**.
- Trabajar con tipos de datos avanzados como `JSONB` y `TIMESTAMPTZ`.
- Aplicar restricciones de integridad y optimizaciones mediante índices.

### Ejemplo: creación de esquema y conexión

```sql
-- Crear un esquema para la tienda
CREATE SCHEMA IF NOT EXISTS tienda;

-- Usar el esquema tienda
SET search_path TO tienda;
```

### Ejemplo: creación de tabla con clave primaria, foránea y tipos avanzados

```sql
CREATE TABLE tienda.cliente (
    id_cliente      SERIAL PRIMARY KEY,
    nombre          VARCHAR(100) NOT NULL,
    email           VARCHAR(150) UNIQUE NOT NULL,
    preferencias    JSONB,               -- Información semiestructurada
    creado_en       TIMESTAMPTZ DEFAULT NOW()  -- Fecha y hora con zona horaria
);

CREATE TABLE tienda.pedido (
    id_pedido       SERIAL PRIMARY KEY,
    id_cliente      INT NOT NULL,
    total           NUMERIC(10,2) NOT NULL,
    estado          VARCHAR(20) NOT NULL,
    creado_en       TIMESTAMPTZ DEFAULT NOW(),
    CONSTRAINT fk_pedido_cliente
        FOREIGN KEY (id_cliente)
        REFERENCES tienda.cliente (id_cliente)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);
```

---

## 3. Temas principales del curso

Los contenidos se organizan en dos grandes bloques:

1. **Modelado de datos**
2. **Consultas avanzadas**

---

## 3.1 Modelado de datos

Incluye el estudio de:

- **Normalización**
- **Desnormalización**
- Uso de **claves primarias** y **claves foráneas** para garantizar la integridad referencial.

### 3.1.1 Normalización

La **normalización** organiza los datos para:

- Reducir la **redundancia**.
- Evitar **anomalías de inserción, actualización y eliminación**.
- Mejorar la consistencia lógica del modelo.

Las formas normales más utilizadas en entornos prácticos son:

| Forma Normal | Objetivo principal                                      | Ejemplo simple                                                  |
|-------------|----------------------------------------------------------|------------------------------------------------------------------|
| 1NF         | Eliminar grupos repetidos y asegurar atomicidad.         | Una columna no debe contener listas (p. ej. “teléfonos” separados por comas). |
| 2NF         | Eliminar dependencia parcial de claves compuestas.       | Atributos no clave dependen de **toda** la clave primaria compuesta. |
| 3NF         | Eliminar dependencias transitivas entre atributos.       | Un atributo no clave no debe depender de otro atributo no clave. |

#### Ejemplo: tabla no normalizada vs. normalizada

**No normalizada (1 tabla con datos repetidos):**

```sql
CREATE TABLE tienda.pedido_no_normalizado (
    id_pedido    INT,
    cliente      VARCHAR(100),
    producto_1   VARCHAR(100),
    producto_2   VARCHAR(100),
    producto_3   VARCHAR(100)
);
```

**Normalizada (separación en tablas relacionadas):**

```sql
CREATE TABLE tienda.cliente (
    id_cliente  SERIAL PRIMARY KEY,
    nombre      VARCHAR(100) NOT NULL
);

CREATE TABLE tienda.pedido (
    id_pedido   SERIAL PRIMARY KEY,
    id_cliente  INT NOT NULL,
    creado_en   TIMESTAMPTZ DEFAULT NOW(),
    FOREIGN KEY (id_cliente) REFERENCES tienda.cliente (id_cliente)
);

CREATE TABLE tienda.pedido_detalle (
    id_pedido_detalle  SERIAL PRIMARY KEY,
    id_pedido          INT NOT NULL,
    producto           VARCHAR(100) NOT NULL,
    cantidad           INT NOT NULL DEFAULT 1,
    FOREIGN KEY (id_pedido) REFERENCES tienda.pedido (id_pedido)
);
```

### 3.1.2 Desnormalización

La **desnormalización** introduce intencionalmente redundancia para:

- Mejorar el rendimiento de ciertas consultas.
- Reducir la necesidad de múltiples `JOIN` en escenarios de **reporting** o análisis.

Se utiliza típicamente en:

- Tablas de resumen (*fact tables* agregadas).
- Tablas de consulta rápida para dashboards.

#### Ejemplo: tabla desnormalizada para reporting

```sql
CREATE TABLE tienda.reporte_ventas_diario (
    fecha               DATE PRIMARY KEY,
    total_pedidos       INT,
    total_clientes      INT,
    total_ingresos      NUMERIC(12,2),
    top_categoria       VARCHAR(100)
    -- Estos datos pueden derivarse de otras tablas, pero se guardan para rapidez
);
```

---

## 3.2 Claves primarias y foráneas

- **Clave primaria (PK)**: Identifica de forma única cada fila.
- **Clave foránea (FK)**: Enlaza una fila con otra tabla, garantizando **integridad referencial**.

### Ejemplo: relación 1–N entre cliente y pedido

```sql
CREATE TABLE tienda.cliente (
    id_cliente  SERIAL PRIMARY KEY,
    nombre      VARCHAR(100) NOT NULL
);

CREATE TABLE tienda.pedido (
    id_pedido   SERIAL PRIMARY KEY,
    id_cliente  INT NOT NULL,
    total       NUMERIC(10,2) NOT NULL,
    FOREIGN KEY (id_cliente)
        REFERENCES tienda.cliente (id_cliente)
);
```

---

## 4. Consultas avanzadas

El segundo gran bloque del curso se centra en el diseño de **consultas eficientes y expresivas**, incluyendo:

- Operaciones **JOIN**.
- **CTEs** (Expresiones de Tabla Comunes).
- **Agrupaciones** y funciones agregadas.
- **Consultas de ventana** (*window functions*).
- **Optimización** e **índices**.

---

## 4.1 Operaciones JOIN

Se utilizan para combinar datos de múltiples tablas según una condición de relación.

| Tipo de JOIN      | Descripción                                        |
|-------------------|----------------------------------------------------|
| `INNER JOIN`      | Devuelve solo las filas que coinciden en ambas tablas. |
| `LEFT JOIN`       | Devuelve todas las filas de la tabla izquierda y las coincidentes de la derecha. |
| `RIGHT JOIN`      | Devuelve todas las filas de la tabla derecha y las coincidentes de la izquierda. |
| `FULL OUTER JOIN` | Devuelve todas las filas de ambas tablas, coincidan o no. |

### Ejemplo: `INNER JOIN` y `LEFT JOIN`

```sql
-- Pedidos con datos de cliente (solo los que tienen cliente asociado)
SELECT
    p.id_pedido,
    c.nombre,
    p.total
FROM tienda.pedido p
INNER JOIN tienda.cliente c
    ON p.id_cliente = c.id_cliente;

-- Todos los clientes, incluso si no tienen pedidos
SELECT
    c.id_cliente,
    c.nombre,
    p.id_pedido,
    p.total
FROM tienda.cliente c
LEFT JOIN tienda.pedido p
    ON c.id_cliente = p.id_cliente;
```

---

## 4.2 CTEs (Common Table Expressions)

Las **CTEs** permiten definir consultas intermedias, reutilizables y más legibles.

- Pueden ser **no recursivas** o **recursivas**.
- Son útiles para:
  - Romper consultas complejas en pasos.
  - Implementar cálculos intermedios.
  - Trabajar con estructuras jerárquicas.

### Ejemplo: CTE para calcular ventas por cliente

```sql
WITH ventas_por_cliente AS (
    SELECT
        c.id_cliente,
        c.nombre,
        SUM(p.total) AS total_compras
    FROM tienda.cliente c
    LEFT JOIN tienda.pedido p
        ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre
)
SELECT *
FROM ventas_por_cliente
WHERE total_compras > 1000
ORDER BY total_compras DESC;
```

---

## 4.3 Agrupación de datos y funciones agregadas

Se utiliza `GROUP BY` junto con funciones como:

- `COUNT`
- `SUM`
- `AVG`
- `MIN`
- `MAX`

### Ejemplo: total de pedidos e ingreso promedio por cliente

```sql
SELECT
    c.id_cliente,
    c.nombre,
    COUNT(p.id_pedido)           AS cantidad_pedidos,
    SUM(p.total)                 AS total_gastado,
    AVG(p.total)                 AS promedio_por_pedido
FROM tienda.cliente c
LEFT JOIN tienda.pedido p
    ON c.id_cliente = p.id_cliente
GROUP BY c.id_cliente, c.nombre
ORDER BY total_gastado DESC;
```

---

## 4.4 Consultas de ventana (Window Functions)

Permiten realizar cálculos sobre un conjunto de filas relacionado con la fila actual, sin agrupar ni colapsar los resultados.

Funciones comunes:

- `ROW_NUMBER()`
- `RANK()`
- `DENSE_RANK()`
- `SUM() OVER (...)` (acumulados)

### Ejemplo: ranking de clientes por total de compras

```sql
WITH ventas AS (
    SELECT
        c.id_cliente,
        c.nombre,
        SUM(p.total) AS total_compras
    FROM tienda.cliente c
    LEFT JOIN tienda.pedido p
        ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre
)
SELECT
    id_cliente,
    nombre,
    total_compras,
    RANK() OVER (ORDER BY total_compras DESC) AS posicion
FROM ventas;
```

### Ejemplo: cálculo de acumulado de ventas por fecha

```sql
SELECT
    fecha,
    ingresos_diarios,
    SUM(ingresos_diarios) OVER (
        ORDER BY fecha
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS ingresos_acumulados
FROM tienda.reporte_ventas_diario
ORDER BY fecha;
```

---

## 4.5 Optimización de consultas e índices

Para mejorar el rendimiento se recurre a:

- **Índices**:
  - B-Tree (por defecto, muy común).
  - Hash.
  - GIST.
  - GIN (especialmente útil para `JSONB`, `ARRAY`, texto, etc.).
- Reescritura de consultas para evitar:
  - Escaneos secuenciales innecesarios.
  - Subconsultas pesadas.
  - Filtros no indexados.

### Ejemplo: índice para búsquedas frecuentes

```sql
-- Índice B-Tree estándar en la columna email de cliente
CREATE INDEX idx_cliente_email
ON tienda.cliente (email);

-- Índice GIN para consultas sobre JSONB (p.ej. preferencias del cliente)
CREATE INDEX idx_cliente_preferencias_gin
ON tienda.cliente
USING GIN (preferencias);
```

### Ejemplo: inspeccionar plan de ejecución

```sql
EXPLAIN ANALYZE
SELECT
    c.nombre,
    p.total
FROM tienda.cliente c
JOIN tienda.pedido p
    ON c.id_cliente = p.id_cliente
WHERE c.email LIKE '%@gmail.com';
```

---

## 5. Objetivo general del curso

Al finalizar, las y los participantes serán capaces de:

- **Diseñar modelos de datos** bien estructurados (normalizados y, cuando corresponda, desnormalizados).
- **Crear y gestionar esquemas y tablas** en PostgreSQL.
- **Definir claves primarias y foráneas**, así como restricciones de integridad.
- **Insertar datos**, incluyendo:
  - Datos aleatorios para pruebas.
  - Datos con tipos avanzados (`JSONB`, `TIMESTAMPTZ`, etc.).
- **Construir consultas avanzadas** utilizando:
  - JOINs.
  - CTEs.
  - Agrupaciones y funciones agregadas.
  - Funciones de ventana.
- **Aplicar técnicas básicas de optimización**, incluyendo el uso efectivo de índices.

```sql
-- Ejemplo final: combinación de varios conceptos
WITH resumen_cliente AS (
    SELECT
        c.id_cliente,
        c.nombre,
        COUNT(p.id_pedido)           AS num_pedidos,
        COALESCE(SUM(p.total), 0)    AS total_compras
    FROM tienda.cliente c
    LEFT JOIN tienda.pedido p
        ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre
)
SELECT
    id_cliente,
    nombre,
    num_pedidos,
    total_compras,
    RANK() OVER (ORDER BY total_compras DESC) AS ranking
FROM resumen_cliente
WHERE total_compras > 0
ORDER BY ranking;
```