# V. Índices y Optimización de Consultas

## 1. Tipos de índices en PostgreSQL

Los **índices** son estructuras auxiliares que aceleran la búsqueda y recuperación de datos, a costa de:

- Mayor uso de espacio en disco.
- Tiempo adicional al insertar, actualizar o eliminar filas.

PostgreSQL ofrece varios tipos de índice, cada uno con usos recomendados:

| Tipo de índice | Uso principal                                         | Ejemplos típicos                           |
|----------------|-------------------------------------------------------|--------------------------------------------|
| **B-Tree**     | Predeterminado. Búsquedas por igualdad y rango.      | `=`, `<`, `>`, `BETWEEN`, `ORDER BY`.      |
| **Hash**       | Comparaciones de igualdad sobre una columna.         | `WHERE columna = valor`.                   |
| **GiST**       | Datos geométricos, rangos, búsqueda aproximada.      | Coordenadas, rangos, búsqueda espacial.    |
| **GIN**        | Datos compuestos / documentos.                       | `JSONB`, arrays, texto completo (`tsvector`). |

### 1.1 Ejemplo: índice B-Tree en tabla de productos

Supongamos una tabla `producto`:

```sql
CREATE TABLE producto (
    id_producto   SERIAL PRIMARY KEY,
    nombre        VARCHAR(150) NOT NULL,
    categoria_id  INT NOT NULL,
    precio        NUMERIC(10,2) NOT NULL
);
```

Crear índices típicos:

```sql
-- Índice B-Tree sobre categoria_id (búsquedas frecuentes por categoría)
CREATE INDEX idx_producto_categoria
    ON producto (categoria_id);

-- Índice para consultas por nombre con igualdad o prefijo (ej. 'Cam%')
CREATE INDEX idx_producto_nombre
    ON producto (nombre);
```

Consulta que se beneficia del índice:

```sql
EXPLAIN ANALYZE
SELECT *
FROM producto
WHERE categoria_id = 10
ORDER BY precio;
```

El plan de ejecución mostrará el uso del índice (`Index Scan`) si el optimizador lo considera conveniente.

---

### 1.2 Índices sobre JSONB y texto completo (GIN / GiST)

Para datos semiestructurados y búsquedas avanzadas se recomiendan índices **GIN** o **GiST**.

#### Ejemplo: índice GIN sobre `JSONB`

```sql
CREATE TABLE producto_extendido (
    id_producto   SERIAL PRIMARY KEY,
    nombre        VARCHAR(150),
    atributos     JSONB  -- ej: {"color": "rojo", "talla": "M"}
);

-- Índice GIN para consultas sobre atributos
CREATE INDEX idx_producto_atributos_gin
    ON producto_extendido
    USING GIN (atributos);
```

Consulta típica:

```sql
SELECT *
FROM producto_extendido
WHERE atributos ->> 'color' = 'rojo';
```

#### Ejemplo: índice GIN para búsqueda de texto completo

```sql
CREATE TABLE articulo (
    id_articulo  SERIAL PRIMARY KEY,
    titulo       TEXT,
    contenido    TEXT
);

-- Columna calculada para texto completo (opcional)
ALTER TABLE articulo
ADD COLUMN contenido_tsv tsvector
    GENERATED ALWAYS AS (
        to_tsvector('spanish', coalesce(titulo,'') || ' ' || coalesce(contenido,''))
    ) STORED;

-- Índice GIN sobre el tsvector
CREATE INDEX idx_articulo_contenido_tsv_gin
    ON articulo
    USING GIN (contenido_tsv);
```

Consulta de texto completo:

```sql
SELECT
    id_articulo,
    titulo
FROM articulo
WHERE contenido_tsv @@ plainto_tsquery('spanish', 'bases de datos');
```

---

## 2. Análisis y Optimización de Rendimiento

La **optimización de consultas** busca que la base de datos responda rápido incluso con:

- Tablas grandes.
- Consultas complejas (`JOIN`, agregaciones, subconsultas).

A continuación se presentan estrategias prácticas.

---

### 2.1 Estrategias de indexación y filtrado

1. **Crear índices en columnas de filtrado frecuente**

   - Columnas usadas constantemente en `WHERE`, `JOIN`, `ORDER BY` o `GROUP BY`.

   ```sql
   -- Índice en categoria_id para consultas filtradas por categoría
   CREATE INDEX idx_producto_categoria
       ON producto (categoria_id);

   -- Índice en email de cliente para búsquedas directas
   CREATE INDEX idx_cliente_email
       ON cliente (email);
   ```

   Ejemplo de consulta optimizable:

   ```sql
   EXPLAIN ANALYZE
   SELECT *
   FROM cliente
   WHERE email = 'usuario@ejemplo.com';
   ```

2. **Evitar escaneos secuenciales innecesarios**

   - Si PostgreSQL no tiene un índice adecuado, recurre a **sequential scan** (lectura de toda la tabla).
   - Para consultas frecuentes sobre una columna:

   ```sql
   CREATE INDEX idx_pedido_fecha
       ON pedido (fecha);

   EXPLAIN ANALYZE
   SELECT *
   FROM pedido
   WHERE fecha BETWEEN '2024-01-01' AND '2024-01-31';
   ```

   Observa en el `EXPLAIN` si aparece `Index Scan` en lugar de `Seq Scan`.

3. **Cuidar el uso de funciones sobre columnas indexadas**

   - Usar funciones directamente sobre la columna puede impedir el uso del índice:

   ```sql
   -- Menos recomendable: puede evitar el uso del índice sobre fecha
   SELECT *
   FROM pedido
   WHERE DATE(fecha) = '2024-01-10';
   ```

   - Mejor reescribir la condición:

   ```sql
   SELECT *
   FROM pedido
   WHERE fecha >= '2024-01-10'::date
     AND fecha <  '2024-01-11'::date;
   ```

---

### 2.2 Optimización de operaciones complejas

4. **Optimizar JOINs**

   - Asegúrate de que las columnas usadas en las uniones estén **indexadas**, al menos en la tabla más grande.

   ```sql
   -- Índice en id_cliente dentro de pedido
   CREATE INDEX idx_pedido_id_cliente
       ON pedido (id_cliente);

   EXPLAIN ANALYZE
   SELECT
       c.nombre,
       p.id_pedido,
       p.total
   FROM cliente c
   JOIN pedido p
       ON c.id_cliente = p.id_cliente
   WHERE p.fecha >= '2024-01-01';
   ```

5. **Agrupación eficiente (`GROUP BY`)**

   - `GROUP BY` puede ser costoso en tablas grandes.
   - Índices en columnas de agrupación pueden ayudar, en especial junto con filtros:

   ```sql
   CREATE INDEX idx_pedido_fecha_cliente
       ON pedido (fecha, id_cliente);

   EXPLAIN ANALYZE
   SELECT
       id_cliente,
       DATE(fecha) AS dia,
       SUM(total) AS total_dia
   FROM pedido
   WHERE fecha >= '2024-01-01'
   GROUP BY id_cliente, DATE(fecha);
   ```

   - Para reportes pesados, considera tablas de **resumen desnormalizadas** (preagregadas).

6. **Particionamiento de tablas grandes**

   - El **particionamiento** divide una tabla grande en varias más pequeñas, normalmente por rango (ej. por fecha).
   - Beneficios:
     - Menos datos a escanear por consulta.
     - Mantenimiento (vacuum, backup) más manejable.

   #### Ejemplo simple de particionamiento por rango de fecha

   ```sql
   -- Tabla particionada de pedidos
   CREATE TABLE pedido (
       id_pedido   SERIAL,
       id_cliente  INT NOT NULL,
       fecha       DATE NOT NULL,
       total       NUMERIC(10,2) NOT NULL
   ) PARTITION BY RANGE (fecha);

   -- Partición para 2024
   CREATE TABLE pedido_2024
       PARTITION OF pedido
       FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
   ```

   Consulta beneficiada (sólo toca la partición 2024):

   ```sql
   SELECT *
   FROM pedido
   WHERE fecha BETWEEN '2024-05-01' AND '2024-05-31';
   ```

7. **JOIN vs subconsultas**

   - No existe una regla absoluta de que las subconsultas sean siempre más rápidas que los `JOIN` o viceversa.
   - En muchos casos, un `JOIN` bien escrito es **más claro** y permite mejores planes de ejecución.
   - Lo importante es:
     - Evitar traer más columnas/filas de las necesarias.
     - Escribir consultas que el optimizador pueda reescribir eficientemente.

   Ejemplo equivalente con JOIN y subconsulta:

   ```sql
   -- Con JOIN
   SELECT c.id_cliente, c.nombre, SUM(p.total) AS total_gastado
   FROM cliente c
   JOIN pedido p ON c.id_cliente = p.id_cliente
   GROUP BY c.id_cliente, c.nombre;

   -- Con subconsulta correlacionada
   SELECT
       c.id_cliente,
       c.nombre,
       (
           SELECT SUM(p.total)
           FROM pedido p
           WHERE p.id_cliente = c.id_cliente
       ) AS total_gastado
   FROM cliente c;
   ```

   Usa `EXPLAIN ANALYZE` para comparar planes y tiempos reales en tu caso concreto.

---

### 2.3 Mantenimiento y actualización de estadísticas

8. **Actualizar estadísticas (ANALYZE)**

   El optimizador de PostgreSQL decide el mejor plan de ejecución basado en **estadísticas** de las tablas e índices.  
   Después de:

   - Cargar grandes volúmenes de datos.
   - Reorganizar / particionar tablas.
   - Hacer cambios importantes en la distribución de datos.

   Es recomendable ejecutar:

   ```sql
   ANALYZE;                  -- Actualiza estadísticas de todas las tablas
   -- o de forma más específica:
   ANALYZE producto;
   ANALYZE pedido;
   ```

9. **Mantenimiento periódico (VACUUM y REINDEX cuando corresponda)**

   - `VACUUM` limpia tuplas muertas y ayuda a mantener el rendimiento.
   - `REINDEX` reconstruye índices dañados o muy fragmentados (casos específicos).

   ```sql
   VACUUM ANALYZE producto;
   -- En casos necesarios:
   REINDEX INDEX idx_producto_categoria;
   ```

---

En resumen, la combinación de:

- **Índices adecuados** (tipo correcto en las columnas correctas),
- **Consultas bien escritas** (filtros claros, JOINs sobre columnas indexadas),
- y **mantenimiento regular** (ANALYZE, VACUUM, particionamiento),

es la clave para lograr un rendimiento sólido y escalable en PostgreSQL.