# II. Modelado de Datos

## 1. Normalización

La **normalización** es el proceso de organizar los datos en una base de datos relacional para:

- **Reducir la redundancia** (datos duplicados).
- **Evitar anomalías** de inserción, actualización y eliminación.
- **Mejorar la coherencia** y la integridad de los datos.

Esto se logra dividiendo tablas grandes en tablas más pequeñas y relacionadas.

### 1.1 Formas normales más utilizadas

En la práctica, las formas normales más usadas son:

| Forma normal | Requisitos principales                                                     | Objetivo clave                            |
|-------------|-----------------------------------------------------------------------------|-------------------------------------------|
| 1NF         | Valores atómicos; sin grupos repetidos ni listas en una sola columna.      | Evitar valores “compuestos” o repetidos. |
| 2NF         | Cumple 1NF + todos los atributos dependen **por completo** de la PK.       | Eliminar dependencias parciales.         |
| 3NF         | Cumple 2NF + no hay dependencias entre atributos que no son clave.         | Eliminar dependencias transitivas.       |

A continuación, se ilustra cada forma con ejemplos prácticos en SQL.

---

### 1.2 Primera Forma Normal (1NF)

**Definición:**  
Una tabla está en 1NF cuando:

- Cada celda contiene **un único valor atómico** (no listas, no valores concatenados).
- No existen columnas que representen grupos repetidos (ej.: `telefono1`, `telefono2`, `telefono3`).

#### Ejemplo: tabla que **no** cumple 1NF

```sql
CREATE TABLE cliente_no_1nf (
    id_cliente  INT PRIMARY KEY,
    nombre      VARCHAR(100),
    telefonos   VARCHAR(255)  -- "555-1111, 555-2222, 555-3333"
);
```

El problema es la columna `telefonos`, que contiene **varios valores** en una sola celda.

#### Ejemplo: tabla normalizada a 1NF

```sql
CREATE TABLE cliente (
    id_cliente  SERIAL PRIMARY KEY,
    nombre      VARCHAR(100) NOT NULL
);

CREATE TABLE cliente_telefono (
    id_telefono SERIAL PRIMARY KEY,
    id_cliente  INT NOT NULL,
    telefono    VARCHAR(50) NOT NULL,
    FOREIGN KEY (id_cliente) REFERENCES cliente (id_cliente)
);
```

Ahora:

- Cada fila de `cliente_telefono` tiene **un solo teléfono**.
- Se pueden registrar tantos teléfonos como se necesiten por cliente.

---

### 1.3 Segunda Forma Normal (2NF)

**Definición:**  
Una tabla está en 2NF cuando:

1. Cumple **1NF**.
2. Todos los atributos no clave dependen **de toda la clave primaria**, no solo de una parte (en caso de clave compuesta).

#### Ejemplo: tabla que **no** cumple 2NF

```sql
CREATE TABLE curso_estudiante (
    id_curso        INT,
    id_estudiante   INT,
    nombre_curso    VARCHAR(100),
    nota_final      NUMERIC(4,2),
    PRIMARY KEY (id_curso, id_estudiante)
);
```

Problema:

- `nombre_curso` depende solo de `id_curso`, **no** de la combinación `(id_curso, id_estudiante)`.
- Es una **dependencia parcial**.

#### Normalización a 2NF

Se separa la información del curso en otra tabla:

```sql
CREATE TABLE curso (
    id_curso      INT PRIMARY KEY,
    nombre_curso  VARCHAR(100) NOT NULL
);

CREATE TABLE curso_estudiante (
    id_curso        INT,
    id_estudiante   INT,
    nota_final      NUMERIC(4,2),
    PRIMARY KEY (id_curso, id_estudiante),
    FOREIGN KEY (id_curso) REFERENCES curso (id_curso)
);
```

Ahora:

- `nombre_curso` reside en `curso`, donde depende solo de su PK `id_curso`.
- `curso_estudiante` solo guarda información que depende de **toda** la clave compuesta.

---

### 1.4 Tercera Forma Normal (3NF)

**Definición:**  
Una tabla está en 3NF cuando:

1. Cumple **2NF**.
2. No existen **dependencias transitivas**: ningún atributo no clave debe depender de otro atributo no clave.

#### Ejemplo: tabla que **no** cumple 3NF

```sql
CREATE TABLE empleado_no_3nf (
    id_empleado      INT PRIMARY KEY,
    nombre           VARCHAR(100),
    id_departamento  INT,
    nombre_departamento VARCHAR(100)
);
```

Problemas:

- `nombre_departamento` depende de `id_departamento`.
- Ambos (`id_departamento`, `nombre_departamento`) son atributos no clave respecto a `id_empleado`.
- Hay una **dependencia transitiva**: `id_empleado → id_departamento → nombre_departamento`.

#### Normalización a 3NF

```sql
CREATE TABLE departamento (
    id_departamento      INT PRIMARY KEY,
    nombre_departamento  VARCHAR(100) NOT NULL
);

CREATE TABLE empleado (
    id_empleado      INT PRIMARY KEY,
    nombre           VARCHAR(100) NOT NULL,
    id_departamento  INT NOT NULL,
    FOREIGN KEY (id_departamento) REFERENCES departamento (id_departamento)
);
```

Ahora:

- `nombre_departamento` se almacena en `departamento`.
- `empleado` solo guarda la referencia mediante `id_departamento`.

---

### 1.5 Resumen de las formas normales (con ejemplos de uso)

| Forma | ¿Qué corrige?                        | Ejemplo típico de corrección                           |
|------|---------------------------------------|--------------------------------------------------------|
| 1NF  | Valores no atómicos, listas, columnas repetidas | Teléfonos separados en filas en lugar de en una sola celda. |
| 2NF  | Dependencias parciales de la clave compuesta    | Separar `curso` y `curso_estudiante`.                  |
| 3NF  | Dependencias entre atributos no clave           | Separar `empleado` y `departamento`.                   |

---

## 2. Desnormalización

La **desnormalización** consiste en **relajar** (a propósito) algunas reglas de normalización para:

- **Mejorar el rendimiento de lectura** (consultas).
- Reducir la cantidad de `JOIN` necesarios.
- Simplificar consultas en escenarios de análisis y *reporting*.

Se logra **introduciendo cierta redundancia** en los datos.  
Es común en:

- Sistemas de inteligencia de negocio.
- Data warehouses.
- Tablas de reportes agregados.

---

### 2.1 Ventajas y desventajas de la desnormalización

| Aspecto        | Ventajas                                                                 | Desventajas                                                                 |
|----------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| Rendimiento    | Consultas más rápidas al evitar múltiples `JOIN`.                       | Actualizaciones más lentas al tener que modificar datos duplicados.        |
| Lectura        | Ideal para sistemas de **lectura intensiva** (dashboards, informes).    | Puede requerir lógica adicional para mantener la coherencia.               |
| Complejidad    | Consultas más sencillas (menos tablas, menos relaciones).              | Lógica de escritura más compleja (insertar/actualizar en varios lugares).  |
| Datos          | Datos ya preparados para análisis (resúmenes, totales, etc.).          | Mayor riesgo de **inconsistencias** por la redundancia.                    |

---

### 2.2 Ejemplo de desnormalización para reporting

Supongamos que tenemos un modelo normalizado de pedidos:

```sql
CREATE TABLE cliente (
    id_cliente  SERIAL PRIMARY KEY,
    nombre      VARCHAR(100)
);

CREATE TABLE pedido (
    id_pedido   SERIAL PRIMARY KEY,
    id_cliente  INT NOT NULL,
    total       NUMERIC(10,2) NOT NULL,
    fecha       DATE NOT NULL,
    FOREIGN KEY (id_cliente) REFERENCES cliente (id_cliente)
);
```

Para un dashboard diario, podríamos crear una tabla **desnormalizada** con datos agregados:

```sql
CREATE TABLE reporte_ventas_diario (
    fecha               DATE PRIMARY KEY,
    total_pedidos       INT,
    total_clientes      INT,
    total_ingresos      NUMERIC(12,2)
);
```

Y poblarla periódicamente:

```sql
INSERT INTO reporte_ventas_diario (fecha, total_pedidos, total_clientes, total_ingresos)
SELECT
    p.fecha,
    COUNT(p.id_pedido)               AS total_pedidos,
    COUNT(DISTINCT p.id_cliente)     AS total_clientes,
    SUM(p.total)                     AS total_ingresos
FROM pedido p
GROUP BY p.fecha;
```

Beneficios:

- Las consultas al dashboard solo leen de `reporte_ventas_diario`, sin recalcular agregados.
- Se evitan `JOIN` y `GROUP BY` costosos en tiempo real.

Costo:

- Si se modifica un pedido histórico, es necesario **recalcular o ajustar** los datos de la fecha afectada en `reporte_ventas_diario`.

---

### 2.3 ¿Cuándo normalizar y cuándo desnormalizar?

- **Normalizar** cuando:
  - Diseñas el modelo transaccional principal.
  - Prioriza la coherencia y la integridad de los datos.
  - Hay muchas operaciones de escritura (OLTP).

- **Desnormalizar** cuando:
  - Necesitas consultas muy rápidas y frecuentes sobre datos agregados.
  - Estás construyendo reportes, dashboards o sistemas analíticos (OLAP).
  - Aceptas cierta complejidad adicional en procesos de carga/actualización (ETL).

```sql
-- Ejemplo de consulta simple sobre tabla desnormalizada
SELECT
    fecha,
    total_pedidos,
    total_ingresos
FROM reporte_ventas_diario
WHERE fecha BETWEEN '2024-01-01' AND '2024-01-31'
ORDER BY fecha;
```

En resumen, la normalización y la desnormalización son **herramientas complementarias**:  
primero se diseña un modelo bien normalizado, y luego se desnormaliza de forma **estratégica** cuando el rendimiento de lectura lo requiere.