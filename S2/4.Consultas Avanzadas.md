# IV. Consultas avanzadas

## 1. Operaciones JOIN (Uniones)

Los **JOIN** se usan para combinar filas de dos o más tablas a partir de columnas relacionadas (generalmente claves primarias y foráneas).

### 1.1 Tipos principales de JOIN

| Tipo de JOIN      | Descripción                                                       |
|-------------------|-------------------------------------------------------------------|
| `INNER JOIN`      | Solo filas con coincidencia en **ambas** tablas.                 |
| `LEFT JOIN`       | Todas las filas de la tabla izquierda + coincidencias de derecha.|
| `RIGHT JOIN`      | Todas las filas de la tabla derecha + coincidencias de izquierda.|
| `FULL OUTER JOIN` | Todas las filas de **ambas** tablas; donde no hay match, `NULL`. |

### 1.2 Esquema de ejemplo

Usaremos estas tablas:

```sql
CREATE TABLE cliente (
    id_cliente  INT PRIMARY KEY,
    nombre      VARCHAR(100)
);

CREATE TABLE pedido (
    id_pedido   INT PRIMARY KEY,
    id_cliente  INT,
    total       NUMERIC(10,2),
    FOREIGN KEY (id_cliente) REFERENCES cliente (id_cliente)
);
```

Datos de ejemplo:

```sql
INSERT INTO cliente (id_cliente, nombre) VALUES
(1, 'Ana'),
(2, 'Luis'),
(3, 'Marta');      -- Marta aún no tiene pedidos

INSERT INTO pedido (id_pedido, id_cliente, total) VALUES
(101, 1, 50.00),
(102, 1, 30.00),
(103, 2, 80.00);
```

### 1.3 Ejemplos de cada JOIN

#### `INNER JOIN`

Devuelve **solo clientes que tienen pedidos**:

```sql
SELECT
    c.id_cliente,
    c.nombre,
    p.id_pedido,
    p.total
FROM cliente c
INNER JOIN pedido p
    ON c.id_cliente = p.id_cliente;
```

Resultado (simplificado):

| id_cliente | nombre | id_pedido | total |
|-----------|--------|-----------|-------|
| 1         | Ana    | 101       | 50.00 |
| 1         | Ana    | 102       | 30.00 |
| 2         | Luis   | 103       | 80.00 |

#### `LEFT JOIN`

Devuelve **todos los clientes**, tengan o no pedidos:

```sql
SELECT
    c.id_cliente,
    c.nombre,
    p.id_pedido,
    p.total
FROM cliente c
LEFT JOIN pedido p
    ON c.id_cliente = p.id_cliente
ORDER BY c.id_cliente;
```

Resultado (Marta aparece con `NULL`):

| id_cliente | nombre | id_pedido | total |
|-----------|--------|-----------|-------|
| 1         | Ana    | 101       | 50.00 |
| 1         | Ana    | 102       | 30.00 |
| 2         | Luis   | 103       | 80.00 |
| 3         | Marta  | NULL      | NULL  |

#### `RIGHT JOIN`

Equivalente a un `LEFT JOIN` pero tomando como base la **tabla derecha**:

```sql
SELECT
    c.id_cliente,
    c.nombre,
    p.id_pedido,
    p.total
FROM cliente c
RIGHT JOIN pedido p
    ON c.id_cliente = p.id_cliente;
```

En este caso, como todos los pedidos tienen cliente, el resultado es el mismo que el `INNER JOIN`.

#### `FULL OUTER JOIN`

Devuelve **todos los clientes y todos los pedidos**, aunque no coincidan:

```sql
SELECT
    c.id_cliente,
    c.nombre,
    p.id_pedido,
    p.total
FROM cliente c
FULL OUTER JOIN pedido p
    ON c.id_cliente = p.id_cliente;
```

Útil cuando quieres ver todo, incluyendo:

- Clientes sin pedidos.
- (En otros casos) pedidos huérfanos, si la integridad no está bien controlada.

---

## 2. Expresiones de Tabla Comunes (CTEs)

Las **CTEs** (*Common Table Expressions*) son subconsultas nombradas que se definen al inicio de una consulta mediante `WITH` y se pueden reutilizar en la misma.

Características:

- Son **temporales**: solo existen durante la ejecución de la consulta.
- Mejoran **legibilidad** y organización de consultas complejas.
- Pueden ser:
  - **No recursivas** (las más comunes).
  - **Recursivas** (útiles para jerarquías).

### 2.1 CTE no recursivo: ejemplo de ventas por cliente

```sql
WITH ventas_por_cliente AS (
    SELECT
        c.id_cliente,
        c.nombre,
        SUM(p.total) AS total_compras
    FROM cliente c
    LEFT JOIN pedido p
        ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre
)
SELECT
    id_cliente,
    nombre,
    total_compras
FROM ventas_por_cliente
WHERE total_compras > 50
ORDER BY total_compras DESC;
```

Ventajas:

- Separas el cálculo intermedio (`ventas_por_cliente`) de la consulta final.
- El código es más fácil de leer y mantener.

### 2.2 CTE recursivo: ejemplo de jerarquía simple

Supongamos una tabla de empleados con jefes:

```sql
CREATE TABLE empleado (
    id_empleado   INT PRIMARY KEY,
    nombre        VARCHAR(100),
    id_jefe       INT NULL REFERENCES empleado (id_empleado)
);
```

CTE recursivo para obtener la jerarquía a partir de un jefe:

```sql
WITH RECURSIVE jerarquia AS (
    -- Nivel raíz: el jefe principal
    SELECT
        e.id_empleado,
        e.nombre,
        e.id_jefe,
        1 AS nivel
    FROM empleado e
    WHERE e.id_empleado = 1  -- jefe inicial

    UNION ALL

    -- Niveles inferiores: subordinados
    SELECT
        e.id_empleado,
        e.nombre,
        e.id_jefe,
        j.nivel + 1 AS nivel
    FROM empleado e
    JOIN jerarquia j
        ON e.id_jefe = j.id_empleado
)
SELECT *
FROM jerarquia
ORDER BY nivel, id_empleado;
```

---

## 3. Agrupación de Datos (`GROUP BY`)

La cláusula `GROUP BY` permite **agrupar filas** que comparten uno o varios valores y aplicar sobre cada grupo **funciones agregadas**.

### 3.1 Funciones agregadas comunes

| Función | Descripción                        | Ejemplo                         |
|--------|------------------------------------|---------------------------------|
| `COUNT`| Cuenta filas                       | `COUNT(*)`                      |
| `SUM`  | Suma valores numéricos             | `SUM(total)`                    |
| `AVG`  | Promedio                           | `AVG(total)`                    |
| `MIN`  | Valor mínimo                       | `MIN(total)`                    |
| `MAX`  | Valor máximo                       | `MAX(total)`                    |

> Nota: `GROUP BY` suele ser más costoso que una consulta simple, porque requiere agrupar y calcular.

### 3.2 Ejemplo: métricas por cliente

```sql
SELECT
    c.id_cliente,
    c.nombre,
    COUNT(p.id_pedido)        AS cantidad_pedidos,
    COALESCE(SUM(p.total), 0) AS total_gastado,
    COALESCE(AVG(p.total), 0) AS promedio_por_pedido
FROM cliente c
LEFT JOIN pedido p
    ON c.id_cliente = p.id_cliente
GROUP BY c.id_cliente, c.nombre
ORDER BY total_gastado DESC;
```

Este tipo de consulta es típico para:

- Reportes de ventas.
- Indicadores de uso.
- Estadísticas por categoría, cliente, fecha, etc.

---

## 4. Consultas de Ventana (*Window Queries*)

Las **funciones de ventana** permiten aplicar cálculos sobre un conjunto de filas **relacionadas con la fila actual**, sin agrupar ni colapsar el resultado (a diferencia de `GROUP BY`).

Se definen usando:

- `OVER (...)`
- Opcionalmente `PARTITION BY` (para dividir en grupos) y `ORDER BY` (para definir el orden dentro de cada grupo).

### 4.1 Funciones de ventana comunes

| Función           | Descripción                                                                 |
|-------------------|-----------------------------------------------------------------------------|
| `ROW_NUMBER()`    | Numera filas secuencialmente dentro de una partición.                      |
| `RANK()`          | Asigna rangos, con **saltos** en caso de empates.                          |
| `DENSE_RANK()`    | Asigna rangos **sin saltos** en caso de empates.                           |
| `SUM() OVER`      | Suma acumulada o por partición, sin agrupar en una sola fila.             |
| `AVG() OVER`      | Promedio móvil o por partición, sin perder el detalle de cada fila.       |

### 4.2 Ejemplo: ranking de clientes por total gastado

Usando la consulta de métricas por cliente como CTE:

```sql
WITH resumen AS (
    SELECT
        c.id_cliente,
        c.nombre,
        COALESCE(SUM(p.total), 0) AS total_gastado
    FROM cliente c
    LEFT JOIN pedido p
        ON c.id_cliente = p.id_cliente
    GROUP BY c.id_cliente, c.nombre
)
SELECT
    id_cliente,
    nombre,
    total_gastado,
    RANK()       OVER (ORDER BY total_gastado DESC) AS rank_con_saltos,
    DENSE_RANK() OVER (ORDER BY total_gastado DESC) AS rank_sin_saltos
FROM resumen
ORDER BY total_gastado DESC;
```

### 4.3 Ejemplo: suma acumulada de ventas por fecha

Supongamos una tabla de ventas diarias:

```sql
CREATE TABLE ventas_diarias (
    fecha   DATE PRIMARY KEY,
    total   NUMERIC(10,2)
);
```

Consulta con acumulado:

```sql
SELECT
    fecha,
    total AS ventas_dia,
    SUM(total) OVER (
        ORDER BY fecha
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS ventas_acumuladas
FROM ventas_diarias
ORDER BY fecha;
```

Aquí:

- `SUM(total) OVER (...)` calcula la **suma acumulada** desde el primer día hasta la fecha actual.
- No se pierde el detalle diario, a diferencia de un `GROUP BY` simple.

---

En conjunto, **JOINs**, **CTEs**, `GROUP BY` y **funciones de ventana** son herramientas clave para construir consultas potentes, legibles y adaptadas tanto a necesidades transaccionales como analíticas.