# VI. Aplicación práctica (Creación y manejo de tablas)

En esta sección se muestran, paso a paso, las operaciones prácticas realizadas para construir el esquema de una base de datos de **tienda** en PostgreSQL:

- Manejo de **esquemas**.
- Creación de tablas con **integridad referencial**.
- Inserción de datos **masivos y aleatorios**.
- Uso de tipos de datos **complejos** (`JSONB`).
- Creación de **índices**.
- Visualización del **modelo**.
- Eliminación de tablas con **relaciones**.

---

## 1. Manejo de esquemas

Si no se especifica un esquema al crear tablas, PostgreSQL las ubica por defecto en `public`.  
Para organizar mejor la base de datos, es recomendable trabajar en un esquema específico, por ejemplo `tienda`.

### 1.1 Crear y usar el esquema `tienda`

```sql
-- Crear el esquema si no existe
CREATE SCHEMA IF NOT EXISTS tienda;

-- Establecer el esquema por defecto para la sesión
SET search_path TO tienda;
```

A partir de este momento, las tablas creadas sin prefijo de esquema se guardarán en `tienda`.

### 1.2 Trasladar tablas desde `public` al esquema `tienda`

Si ya creaste tablas en `public`, puedes moverlas con `ALTER TABLE ... SET SCHEMA`:

```sql
-- Mover la tabla categoria del esquema public al esquema tienda
ALTER TABLE public.categoria
SET SCHEMA tienda;

-- Mover la tabla producto
ALTER TABLE public.producto
SET SCHEMA tienda;
```

---

## 2. Creación de tablas con integridad referencial

Se definen tablas **maestras** (como `categoria`) y tablas **transaccionales** (como `producto`), usando `PRIMARY KEY`, `FOREIGN KEY`, `UNIQUE`, `CHECK`, etc.

### 2.1 Tablas maestras y transaccionales

#### Tabla `categoria` (autorreferenciada)

```sql
CREATE TABLE tienda.categoria (
    categoria_id       SERIAL PRIMARY KEY,
    nombre             VARCHAR(100) NOT NULL UNIQUE,
    descripcion        TEXT,
    categoria_padre_id INT,
    FOREIGN KEY (categoria_padre_id)
        REFERENCES tienda.categoria (categoria_id)
        ON DELETE SET NULL  -- Si se elimina la categoría padre, el campo se pone en NULL
);
```

#### Tabla `producto`

```sql
CREATE TABLE tienda.producto (
    producto_id   SERIAL PRIMARY KEY,
    categoria_id  INT NOT NULL,
    nombre        VARCHAR(150) NOT NULL,
    descripcion   TEXT,
    precio        NUMERIC(10,2) NOT NULL,
    stock         INT NOT NULL DEFAULT 0,
    codigo        VARCHAR(50) NOT NULL UNIQUE,
    CONSTRAINT fk_producto_categoria
        FOREIGN KEY (categoria_id)
        REFERENCES tienda.categoria (categoria_id)
        ON DELETE RESTRICT   -- No permite borrar una categoría con productos asociados
);
```

#### Tabla `imagen_producto`

```sql
CREATE TABLE tienda.imagen_producto (
    imagen_id    SERIAL PRIMARY KEY,
    producto_id  INT NOT NULL,
    url_imagen   TEXT NOT NULL,
    FOREIGN KEY (producto_id)
        REFERENCES tienda.producto (producto_id)
        ON DELETE CASCADE  -- Si se borra el producto, se borran sus imágenes
);
```

#### Tablas `usuario` y `cliente`

```sql
CREATE TABLE tienda.usuario (
    usuario_id   SERIAL PRIMARY KEY,
    email        VARCHAR(150) NOT NULL UNIQUE,
    password     TEXT NOT NULL,
    creado_en    TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE tienda.cliente (
    cliente_id        SERIAL PRIMARY KEY,
    usuario_id        INT NOT NULL UNIQUE,  -- Un cliente por usuario
    fecha_nacimiento  DATE,
    genero            VARCHAR(10),
    puntos_fidelidad  INT NOT NULL DEFAULT 0,
    CONSTRAINT fk_cliente_usuario
        FOREIGN KEY (usuario_id)
        REFERENCES tienda.usuario (usuario_id)
        ON DELETE CASCADE, -- Si se borra el usuario, se borra el cliente
    CONSTRAINT chk_genero_valido
        CHECK (genero IN ('masculino', 'femenino', 'otro'))
);
```

---

## 3. Inserción de datos aleatorios y masivos

Para poblar tablas con muchos registros de prueba se usa `GENERATE_SERIES` junto con `RANDOM()`.

### 3.1 Generar categorías de prueba

```sql
INSERT INTO tienda.categoria (nombre, descripcion)
SELECT
    'Categoría ' || i AS nombre,
    'Descripción de la categoría ' || i AS descripcion
FROM generate_series(1, 30) AS s(i);
```

### 3.2 Generar productos de forma masiva

```sql
INSERT INTO tienda.producto (
    categoria_id,
    nombre,
    descripcion,
    precio,
    stock,
    codigo
)
SELECT
    (RANDOM() * 29 + 1)::INT AS categoria_id,          -- valor entre 1 y 30
    'Producto ' || i        AS nombre,
    'Descripción del producto ' || i AS descripcion,
    (RANDOM() * 100 + 1)::NUMERIC(10,2) AS precio,     -- precio entre 1 y 101
    (RANDOM() * 100)::INT   AS stock,
    'PROD-' || i            AS codigo
FROM generate_series(1, 200) AS s(i);
```

### 3.3 Insertar imágenes de productos

```sql
INSERT INTO tienda.imagen_producto (producto_id, url_imagen)
SELECT
    (RANDOM() * 199 + 1)::INT AS producto_id,          -- producto_id entre 1 y 200
    'https://example.com/img/prod_' || i || '.jpg'
FROM generate_series(1, 400) AS s(i);
```

---

## 4. Almacenamiento de registros complejos con `JSONB`

PostgreSQL permite almacenar estructuras no relacionales usando el tipo `JSONB`. Es ideal para datos:

- Semiestructurados.
- Variables entre registros.
- Que no justifican normalización completa.

### 4.1 Crear tabla `skill_json`

```sql
CREATE TABLE tienda.skill_json (
    id_skill  SERIAL PRIMARY KEY,
    datos     JSONB NOT NULL
);
```

### 4.2 Insertar registros JSONB

```sql
INSERT INTO tienda.skill_json (datos) VALUES
(
    '{
        "nombre": "Carlos",
        "pais": "España",
        "direccion": {
            "ciudad": "Madrid",
            "calle": "Gran Vía 123"
        },
        "habilidades": ["SQL", "PostgreSQL", "JSONB"]
    }'::jsonb
),
(
    '{
        "nombre": "Laura",
        "pais": "México",
        "direccion": {
            "ciudad": "CDMX",
            "calle": "Insurgentes 456"
        },
        "habilidades": ["Python", "Data Science"]
    }'::jsonb
);
```

### 4.3 Consultar campos dentro de JSONB

```sql
-- Obtener nombre y ciudad
SELECT
    datos->>'nombre'                      AS nombre,
    datos->'direccion'->>'ciudad'         AS ciudad
FROM tienda.skill_json;

-- Filtrar por país usando operador de contención (@>)
SELECT *
FROM tienda.skill_json
WHERE datos @> '{"pais": "España"}';
```

---

## 5. Creación de índices para rendimiento

Para acelerar búsquedas y uniones frecuentes, se crean índices con `CREATE INDEX`.

### 5.1 Índice en `categoria_id` de `producto`

```sql
CREATE INDEX idx_producto_categoria
    ON tienda.producto (categoria_id);
```

Consulta optimizada:

```sql
EXPLAIN ANALYZE
SELECT *
FROM tienda.producto
WHERE categoria_id = 5;
```

### 5.2 Índice GIN sobre `JSONB` (opcional)

```sql
CREATE INDEX idx_skill_json_datos_gin
    ON tienda.skill_json
    USING GIN (datos);
```

Consulta que aprovecha el índice:

```sql
EXPLAIN ANALYZE
SELECT *
FROM tienda.skill_json
WHERE datos @> '{"habilidades": ["SQL"]}';
```

---

## 6. Visualización del modelo

Una vez creadas las tablas y relaciones, es útil **visualizar** el modelo:

- Con herramientas como **pgAdmin**, **DBeaver**, **DataGrip**, etc., que generan el **DER** (Diagrama Entidad–Relación) a partir de la base de datos.
- O inspeccionando metadatos desde SQL.

### 6.1 Ejemplo: listar claves foráneas desde SQL

```sql
SELECT
    tc.table_schema,
    tc.table_name,
    kcu.column_name,
    ccu.table_name  AS tabla_referenciada,
    ccu.column_name AS columna_referenciada
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
  AND tc.table_schema = 'tienda'
ORDER BY tc.table_name;
```

---

## 7. Eliminación de tablas relacionadas

Cuando una tabla está referenciada por otras mediante claves foráneas, no se puede eliminar directamente sin romper la integridad referencial.

### 7.1 Intento de eliminación sin `CASCADE`

```sql
-- Esto generará un error si existen imágenes que referencian a producto
DROP TABLE tienda.producto;
```

Error típico:

> ERROR: cannot drop table producto because other objects depend on it

En este caso, la tabla `imagen_producto` depende de `producto`.

### 7.2 Uso de `DROP TABLE ... CASCADE`

Para forzar la eliminación de la tabla **y todos los objetos dependientes**:

```sql
DROP TABLE tienda.producto CASCADE;
```

Esto eliminará:

- La tabla `producto`.
- Las claves foráneas y las tablas/objetos que dependan de ella (por ejemplo, `imagen_producto`).

> Advertencia: `CASCADE` es una operación **destructiva**. Úsala solo si estás seguro de que quieres eliminar todos los objetos relacionados.

---

Con estas prácticas, se cubre el ciclo completo de:

1. Diseñar y organizar un esquema.
2. Crear tablas con relaciones sólidas.
3. Poblar con datos masivos.
4. Manejar datos complejos (`JSONB`).
5. Optimizar con índices.
6. Visualizar el modelo.
7. Administrar (incluida la eliminación segura) de tablas relacionadas.