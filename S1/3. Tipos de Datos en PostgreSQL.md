## Separata: Tipos de Datos en PostgreSQL

Esta separata resume los **tipos de datos más usados en PostgreSQL** y cómo emplearlos al definir tablas y columnas. Incluye ejemplos prácticos en SQL para reforzar la comprensión.

---

## A. Tipos Numéricos

PostgreSQL ofrece varios tipos numéricos para trabajar con **enteros**, **decimales exactos** y **punto flotante**.

### 1. Enteros

| Tipo       | Tamaño   | Rango aproximado                    | Uso típico                        |
|-----------|----------|--------------------------------------|-----------------------------------|
| `SMALLINT`| 2 bytes  | −32 768 a 32 767                     | Contadores pequeños, flags        |
| `INTEGER` / `INT` | 4 bytes | −2 mil millones aprox.        | IDs, contadores generales         |
| `BIGINT`  | 8 bytes  | ±9 cuatrillones aprox.              | IDs muy grandes, estadísticas     |

Ejemplo:

```sql
CREATE TABLE productos (
    id_producto  BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    stock_actual INTEGER NOT NULL,
    stock_minimo SMALLINT NOT NULL
);
```

---

### 2. Decimales exactos

| Tipo                     | Descripción                                                | Ejemplo común     |
|--------------------------|------------------------------------------------------------|-------------------|
| `DECIMAL(p, s)`          | Decimal exacto con precisión `p` y escala `s`.            | Valores monetarios |
| `NUMERIC(p, s)`          | Equivalente a `DECIMAL` en PostgreSQL.                    | Cálculos financieros |

- `p` = cantidad total de dígitos.
- `s` = cantidad de dígitos a la derecha del punto decimal.

Ejemplo:

```sql
CREATE TABLE facturas (
    id_factura BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    total      NUMERIC(12, 2) NOT NULL   -- hasta 9999999999.99
);
```

---

### 3. Punto flotante (aproximado)

| Tipo              | Tamaño   | Descripción                                  |
|-------------------|----------|----------------------------------------------|
| `REAL`            | 4 bytes  | Precisión simple (aproximada).               |
| `DOUBLE PRECISION`| 8 bytes  | Precisión doble (aproximada).                |

Son útiles para cálculos científicos o mediciones donde no se necesita precisión exacta.

Ejemplo:

```sql
CREATE TABLE sensores (
    id_sensor    SERIAL PRIMARY KEY,
    lectura_temp REAL,             -- temperatura aproximada
    lectura_prec DOUBLE PRECISION  -- medición más precisa
);
```

---

## B. Tipos de Cadena de Texto

PostgreSQL maneja texto con gran flexibilidad.

| Tipo        | Descripción                                                 |
|-------------|-------------------------------------------------------------|
| `VARCHAR(n)`| Texto de longitud variable con límite máximo de `n`.        |
| `CHAR(n)`   | Texto de longitud fija; se rellena con espacios si falta.   |
| `TEXT`      | Texto de longitud prácticamente ilimitada.                  |

Ejemplo:

```sql
CREATE TABLE clientes (
    id_cliente     SERIAL PRIMARY KEY,
    nombre         VARCHAR(100) NOT NULL,
    codigo_pais    CHAR(2) NOT NULL,     -- Ej: "PE", "MX", "AR"
    notas          TEXT                  -- comentarios extensos
);
```

---

## C. Tipos Lógicos, de Fecha y Tiempo

### 1. Tipo lógico

| Tipo       | Valores posibles              |
|-----------|--------------------------------|
| `BOOLEAN` | `TRUE`, `FALSE` o `NULL`.      |

Ejemplo:

```sql
CREATE TABLE usuarios (
    id_usuario SERIAL PRIMARY KEY,
    email      VARCHAR(200) NOT NULL UNIQUE,
    activo     BOOLEAN NOT NULL DEFAULT TRUE
);
```

---

### 2. Fechas y horas

| Tipo                          | Descripción                                           |
|-------------------------------|-------------------------------------------------------|
| `DATE`                        | Solo fecha (año, mes, día).                          |
| `TIME [WITHOUT TIME ZONE]`    | Solo hora (sin fecha).                               |
| `TIMESTAMP`                   | Fecha y hora (sin zona horaria).                     |
| `TIMESTAMPTZ` (`TIMESTAMP WITH TIME ZONE`) | Fecha y hora con zona horaria. |
| `INTERVAL`                    | Periodo de tiempo (duración).                        |

Ejemplos:

```sql
CREATE TABLE eventos (
    id_evento    SERIAL PRIMARY KEY,
    titulo       VARCHAR(200) NOT NULL,
    fecha        DATE NOT NULL,
    hora_inicio  TIME NOT NULL,
    creado_en    TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    duracion     INTERVAL       -- Ej: '2 hours', '3 days'
);
```

Uso de intervalos en consultas:

```sql
-- Eventos programados para dentro de los próximos 7 días
SELECT *
FROM eventos
WHERE fecha BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL '7 days';
```

---

## D. Tipos Estructurados y “NoSQL”

PostgreSQL destaca por su soporte avanzado de tipos **semiestructurados**, ideal para escenarios híbridos SQL/NoSQL.

### 1. JSON y JSONB

| Tipo    | Descripción                                                |
|---------|------------------------------------------------------------|
| `JSON`  | Almacena el JSON como texto, conservando el formato original. |
| `JSONB` | JSON en formato binario; más eficiente para búsquedas e índices. |

Ejemplo de tabla con `JSONB`:

```sql
CREATE TABLE pedidos (
    id_pedido    SERIAL PRIMARY KEY,
    cliente_id   INT NOT NULL,
    detalle_json JSONB NOT NULL        -- Ej: {"items":[...], "metodo_pago":"tarjeta"}
);
```

Consulta sobre campos JSONB:

```sql
-- Pedidos pagados con tarjeta
SELECT id_pedido, detalle_json
FROM pedidos
WHERE detalle_json->>'metodo_pago' = 'tarjeta';

-- Acceder a un arreglo dentro del JSON
SELECT detalle_json->'items' AS items
FROM pedidos
WHERE id_pedido = 1;
```

Índice GIN sobre JSONB:

```sql
CREATE INDEX idx_pedidos_detalle_json
ON pedidos
USING GIN (detalle_json);
```

---

### 2. ARRAY

Los **arrays** permiten almacenar listas de valores del mismo tipo en una sola columna.

Ejemplos de tipos:

- `INTEGER[]`
- `TEXT[]`
- `UUID[]`

Creación de tabla con `ARRAY`:

```sql
CREATE TABLE cursos (
    id_curso     SERIAL PRIMARY KEY,
    nombre       VARCHAR(200) NOT NULL,
    etiquetas    TEXT[]                -- Ej: ['sql','postgres','avanzado']
);
```

Insertar y consultar arrays:

```sql
INSERT INTO cursos (nombre, etiquetas)
VALUES ('PostgreSQL Avanzado', ARRAY['sql','postgres','avanzado']);

-- Buscar cursos que tengan la etiqueta 'postgres'
SELECT *
FROM cursos
WHERE 'postgres' = ANY (etiquetas);
```

---

### 3. HSTORE

`HSTORE` almacena **pares clave–valor** (similar a un diccionario pequeño) en una sola columna.

> Nota: requiere habilitar primero la extensión.

```sql
CREATE EXTENSION IF NOT EXISTS hstore;

CREATE TABLE productos_ext (
    id_producto SERIAL PRIMARY KEY,
    nombre      VARCHAR(100) NOT NULL,
    atributos   HSTORE                -- Ej: 'color=>"rojo", talla=>"M"'
);
```

Uso:

```sql
INSERT INTO productos_ext (nombre, atributos)
VALUES ('Camiseta', 'color=>"rojo", talla=>"M"');

-- Obtener productos de color rojo
SELECT *
FROM productos_ext
WHERE atributos->'color' = 'rojo';
```

---

## Resumen

PostgreSQL ofrece un **conjunto muy rico de tipos de datos**:

- **Básicos:** `INTEGER`, `NUMERIC`, `VARCHAR`, `TEXT`, `BOOLEAN`, `DATE`, `TIMESTAMP`.
- **Avanzados:** `JSONB`, `ARRAY`, `HSTORE`, tipos geométricos, rangos, etc.

Esta variedad permite:

- Modelar datos relacionales clásicos con precisión.
- Trabajar con datos **semiestructurados / NoSQL** sin abandonar la solidez del modelo relacional.
- Optimizar consultas mediante tipos adecuados e índices especializados.

Elegir correctamente el tipo de dato es el primer paso para diseñar **esquemas robustos, eficientes y fáciles de mantener** en PostgreSQL.