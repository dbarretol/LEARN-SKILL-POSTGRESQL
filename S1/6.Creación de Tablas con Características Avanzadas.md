## Separata Detallada: Creación de Tablas con Características Avanzadas en PostgreSQL

### VI. Creación de Tablas con Características Avanzadas

Esta sección se centra en técnicas avanzadas de PostgreSQL para la definición de tablas, incluyendo la generación de identificadores únicos (IDs), la implementación de validaciones (*constraints*) y el uso de tipos de datos personalizados como ENUM.

#### A. Extensiones y Generación de IDs Únicos

Para las tablas que requieren una identificación única robusta, como las tablas de usuarios, se utiliza el concepto de **Extensiones**.

1.  **UUID (Identificador Único Universal):** En lugar de usar números enteros seriales, se puede optar por el UUID.
    *   **Propósito:** Generar códigos únicos de IDs.
    *   **Características:** La extensión UUID genera un identificador de **128 bytes**, el cual es **único a nivel mundial**, evitando la duplicación de claves. Un código UUID se presenta en un formato que incluye guiones (ejemplo: `código-código-código-código-código`).
    *   **Implementación:** Se debe crear la extensión utilizando la sentencia `CREATE EXTENSION IF NOT EXISTS`.

2.  **Funciones para Generación Aleatoria:** Se define la necesidad de crear una función llamada `random_string` para generar texto aleatorio,.
    *   **Uso:** Esta función genera valores únicos para campos como contraseñas, nombres de usuario temporales u otros datos de prueba.
    *   **Mecanismo:** La función utiliza el lenguaje **PL/pgSQL** (PL Posgre SQL), declara variables locales y emplea un bucle `FOR`. Utiliza la función `random()` (genera un número decimal entre 0 y 1) y `substring` para seleccionar caracteres de forma aleatoria de una cadena de caracteres predefinida (incluyendo letras mayúsculas, minúsculas y números del 0 al 9),.

#### B. Definición de la Tabla de Usuarios

La tabla de ejemplo `usuario` se crea incorporando la extensión UUID y diversas restricciones para asegurar la integridad de los datos.

1.  **Clave Primaria con UUID:**
    *   La columna `usuario_ID` se define con el tipo **`UUID`** y se establece como **`PRIMARY KEY`**.
    *   Se utiliza el valor por defecto (**`DEFAULT uuid_generate_v4()`**) para generar IDs de forma aleatoria (versión 4) al insertar nuevos registros,.

2.  **Validación de Datos (Constraints):** Se implementan varias restricciones de validación:
    *   **`NOT NULL`:** Se utiliza para asegurar que campos como `nombres`, `apellidos`, `email` y `password` contengan datos,.
    *   **`UNIQUE`:** El campo `email` se marca como único para prevenir duplicidad.
    *   **`CHECK` constraints:** Se emplean para validar el formato del `email` a través de una expresión regular compleja,. Esto garantiza que el valor insertado cumpla con un patrón de correo electrónico específico. También se utiliza un `CHECK` para restringir los valores posibles del campo `estado` (activo, suspendido, etc.).

3.  **Tipos de Datos de Fecha y Hora:**
    *   Para el registro de la fecha de creación (`fecha_de_creacion`), se utiliza el tipo **`TIMESTAMP WITH TIME ZONE`** y se establece el valor por defecto como `CURRENT_TIMESTAMP`. Esto asegura que la fecha y hora se guarden con referencia a la zona horaria.
    *   Para registrar el momento del último inicio de sesión (`último_login`), se utiliza también `TIMESTAMP WITH TIME ZONE`.
    *   Se utiliza el tipo de dato **`BOOLEAN`** para el campo `es_admin`, estableciendo un valor por defecto de `TRUE` o `FALSE`,.

#### C. Tipos Personalizados (ENUM)

Se ofrece la opción de manejar los estados de usuario mediante un tipo personalizado **`ENUM`** (enumeración), lo cual es una alternativa a usar el *constraint* `CHECK` sobre un campo `VARCHAR`.

1.  **Creación del Tipo ENUM:** Se crea un nuevo tipo de dato llamado `estado_de_usuario`.
    *   **Sentencia:** `CREATE TYPE AS ENUM`.
    *   **Definición:** Este tipo se define para aceptar solo un conjunto predefinido de valores, como **`activo`**, **`inactivo`** y **`suspendido`**.

2.  **Uso en la Tabla:** Una vez creado el tipo, el campo `estado` de la tabla `usuario` ya no es `VARCHAR`, sino que utiliza el tipo **`estado_de_usuario`** y se le asigna un valor por defecto, como `activo`. Esta práctica es comparable a la forma en que se manejan los tipos en sistemas como Oracle,.