## Separata: Creación de Tablas con Características Avanzadas en PostgreSQL

Esta separata se centra en técnicas avanzadas para definir tablas en PostgreSQL:

- Generación de **identificadores únicos (UUID)**.
- Validaciones mediante **constraints**.
- Uso de **tipos personalizados** como `ENUM`.

Incluye ejemplos prácticos en SQL para que puedas reutilizarlos en tus propios diseños.

---

## A. Extensiones y Generación de IDs Únicos

En aplicaciones reales (usuarios, pedidos, tokens, etc.) suele ser recomendable usar **UUIDs** en lugar de enteros autoincrementales, especialmente cuando:

- Hay múltiples sistemas generando IDs.
- Se quieren evitar colisiones entre servidores.
- Se necesita ocultar la secuencia real de registros.

---

### 1. UUID (Identificador Único Universal)

En lugar de `SERIAL` o `BIGSERIAL`, puedes usar el tipo **`UUID`**.

**Características:**

- Tamaño: **128 bits (16 bytes)**.
- Muy alta probabilidad de unicidad global.
- Formato típico (texto con guiones):  
  `550e8400-e29b-41d4-a716-446655440000`.

Existen dos extensiones comunes para generar UUIDs:

| Extensión    | Función típica           | Comentario                              |
|--------------|--------------------------|-----------------------------------------|
| `uuid-ossp`  | `uuid_generate_v4()`     | Genera UUID v4 (aleatorio).            |
| `pgcrypto`   | `gen_random_uuid()`      | También genera UUID v4; muy utilizada. |

Activar una de las extensiones (ejemplo: `uuid-ossp`):

```sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

Uso en una tabla:

```sql
CREATE TABLE usuario (
    usuario_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nombres    VARCHAR(100) NOT NULL
    -- más columnas...
);
```

Alternativa con `pgcrypto`:

```sql
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

CREATE TABLE usuario (
    usuario_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nombres    VARCHAR(100) NOT NULL
    -- más columnas...
);
```

---

### 2. Función para generar cadenas aleatorias (texto)

A veces necesitas **cadenas aleatorias** (por ejemplo, para tokens, contraseñas temporales, códigos de verificación).  
Puedes crear una función en **PL/pgSQL**:

```sql
CREATE OR REPLACE FUNCTION random_string(p_length INT)
RETURNS TEXT AS
$$
DECLARE
    chars   TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    result  TEXT := '';
    i       INT;
BEGIN
    FOR i IN 1..p_length LOOP
        result := result || substr(
            chars,
            (random() * length(chars) + 1)::INT,
            1
        );
    END LOOP;

    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

Ejemplo de uso:

```sql
SELECT random_string(10) AS token;
-- Posible resultado: 'aK3X9tzB1Q'
```

---

## B. Definición de la tabla de usuarios con constraints

A continuación se muestra una tabla `usuario` con:

- **UUID** como clave primaria.
- Validaciones de email y estado.
- Marcas de tiempo y campo booleano.

### 1. Creación de la tabla `usuario` (versión básica)

```sql
CREATE TABLE usuario (
    usuario_id      UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nombres         VARCHAR(100) NOT NULL,
    apellidos       VARCHAR(100) NOT NULL,
    email           VARCHAR(255) NOT NULL UNIQUE,
    password        TEXT NOT NULL,
    estado          VARCHAR(20) NOT NULL,
    fecha_creacion  TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ultimo_login    TIMESTAMPTZ,
    es_admin        BOOLEAN NOT NULL DEFAULT FALSE
);
```

---

### 2. Validación de datos con constraints

**Constraints** principales:

| Tipo        | Uso                                               |
|-------------|---------------------------------------------------|
| `NOT NULL`  | Obliga a que la columna siempre tenga un valor.   |
| `UNIQUE`    | Prohíbe valores duplicados en la columna.         |
| `CHECK`     | Valida reglas específicas (expresiones lógicas).  |
| `PRIMARY KEY` | Identificador único de cada fila.              |

Ejemplos:

#### a) Validación de formato de email (CHECK)

PostgreSQL permite usar expresiones regulares con el operador `~` (sensible a mayúsculas/minúsculas) o `~*` (insensible).

```sql
ALTER TABLE usuario
ADD CONSTRAINT chk_usuario_email
CHECK (
    email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'
);
```

> Nota: Los patrones de email perfectos son complejos; este es un filtro razonable para muchos casos.

#### b) Valores permitidos para `estado` (CHECK)

```sql
ALTER TABLE usuario
ADD CONSTRAINT chk_usuario_estado
CHECK (estado IN ('activo', 'inactivo', 'suspendido'));
```

---

### 3. Ejemplos de inserción y actualización

```sql
-- Insertar un usuario
INSERT INTO usuario (nombres, apellidos, email, password, estado, es_admin)
VALUES (
    'Ana',
    'Pérez',
    'ana.perez@example.com',
    random_string(16),
    'activo',
    FALSE
);

-- Actualizar último login
UPDATE usuario
SET ultimo_login = NOW()
WHERE email = 'ana.perez@example.com';
```

---

## C. Tipos personalizados (ENUM)

En lugar de `VARCHAR` + `CHECK`, PostgreSQL permite definir tipos **`ENUM`** para restringir una columna a un conjunto fijo de valores.

Ventajas:

- Tipado más **estricto** a nivel de base de datos.
- Código más legible.
- Menos riesgo de errores ortográficos en los valores.

---

### 1. Creación del tipo `ENUM` para estado de usuario

```sql
CREATE TYPE estado_de_usuario AS ENUM ('activo', 'inactivo', 'suspendido');
```

---

### 2. Uso del `ENUM` en la tabla `usuario`

Ahora se redefine la columna `estado` para usar el nuevo tipo:

```sql
CREATE TABLE usuario (
    usuario_id      UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    nombres         VARCHAR(100) NOT NULL,
    apellidos       VARCHAR(100) NOT NULL,
    email           VARCHAR(255) NOT NULL UNIQUE,
    password        TEXT NOT NULL,
    estado          estado_de_usuario NOT NULL DEFAULT 'activo',
    fecha_creacion  TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    ultimo_login    TIMESTAMPTZ,
    es_admin        BOOLEAN NOT NULL DEFAULT FALSE
);
```

Ejemplo de inserción:

```sql
INSERT INTO usuario (nombres, apellidos, email, password, estado)
VALUES (
    'Juan',
    'López',
    'juan.lopez@example.com',
    random_string(12),
    'suspendido'
);
```

> Si intentas insertar `estado = 'bloqueado'`, PostgreSQL mostrará un error porque no es un valor válido de `estado_de_usuario`.

---

## Resumen

En esta separata has visto cómo:

- Usar **UUID** como clave primaria con extensiones (`uuid-ossp` o `pgcrypto`).
- Crear funciones en **PL/pgSQL** para generar cadenas aleatorias.
- Definir una tabla `usuario` con múltiples **constraints** (`NOT NULL`, `UNIQUE`, `CHECK`).
- Reemplazar `VARCHAR` + `CHECK` por un tipo **`ENUM`** (`estado_de_usuario`) para un control más estricto de los valores permitidos.

Estas técnicas son fundamentales para diseñar **esquemas robustos**, seguros y fáciles de mantener en PostgreSQL.