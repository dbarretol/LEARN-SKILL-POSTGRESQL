## Separata: Inserción de Registros de Forma Aleatoria en PostgreSQL

Esta separata muestra cómo realizar **inserciones masivas de datos de prueba** en PostgreSQL combinando:

- `INSERT INTO ... SELECT`
- `generate_series`
- `random`
- `MD5`
- Expresiones `CASE`

El objetivo es poblar la tabla `usuario` con muchos registros de forma **rápida, controlada y reproducible**.

---

## 1. Inserción masiva con `INSERT INTO ... SELECT`

En lugar de insertar fila por fila con múltiples `INSERT`, utilizamos un único `INSERT` que toma sus datos de un `SELECT`:

```sql
INSERT INTO usuario (nombres, apellidos, email, password, telefono, es_admin)
SELECT
    -- columnas generadas aquí
FROM
    generate_series(1, 100) AS i;
```

Puntos clave:

- En la lista de columnas del `INSERT` solo se incluyen las columnas que **no tienen `DEFAULT` automático** (por ejemplo, el `UUID` si se genera con `DEFAULT uuid_generate_v4()`).
- La parte `SELECT ... FROM generate_series(...)` es la que **fabrica los datos** de prueba.

---

## 2. Generación de filas con `generate_series`

La función:

```sql
generate_series(1, 100)
```

genera una **secuencia de enteros** del 1 al 100.  
Cada valor se referencia como `i` y nos sirve para variar los valores de cada fila.

Ejemplo básico:

```sql
SELECT i
FROM generate_series(1, 5) AS i;
```

Resultado:

```text
 i
---
 1
 2
 3
 4
 5
```

En el contexto del `INSERT`:

```sql
FROM generate_series(1, 100) AS i
```

- Se crearán **100 filas**.
- Cada fila tendrá un valor distinto de `i` (1, 2, 3, ..., 100).

---

## 3. Generación de nombres, apellidos y correos

Aprovechamos `i` para generar datos diferenciados por fila.

### 3.1. Nombres y apellidos

```sql
'skill_nombre_'   || i AS nombres,
'skill_apellido_' || i AS apellidos,
```

Ejemplos resultantes:

- `skill_nombre_1`, `skill_apellido_1`
- `skill_nombre_2`, `skill_apellido_2`
- ...

### 3.2. Correos electrónicos

```sql
LOWER('skill' || i || '@skill.com') AS email,
```

- Para `i = 1` → `skill1@skill.com`
- Para `i = 2` → `skill2@skill.com`

Se usa `LOWER` para asegurar que el email quede en minúsculas.

---

## 4. Generación y hash de contraseñas con `MD5` y `random()`

Para crear contraseñas de prueba:

- `random()` → número decimal aleatorio entre 0 y 1.
- `MD5(text)` → hash MD5 de una cadena de texto.

Ejemplo:

```sql
MD5(random()::TEXT) AS password,
```

Cada fila:

- Obtiene un `random()` distinto.
- Se castea a texto (`::TEXT`).
- Se aplica `MD5`, produciendo una cadena hexadecimal de 32 caracteres.

> Importante:  
> MD5 **no es recomendable en producción** para almacenar contraseñas reales.  
> Se usa aquí solo con fines de **prueba y demostración**.

---

## 5. Datos condicionales con `CASE WHEN` (teléfono y `es_admin`)

Para que los datos no sean totalmente aleatorios y sigan ciertos **patrones controlados**, usamos `CASE` junto con el operador módulo (`%`).

### 5.1. Ejemplo: teléfonos “repetidos”

```sql
CASE
    WHEN i % 3 = 0 THEN '999-111-000'
    WHEN i % 3 = 1 THEN '999-222-000'
    ELSE              '999-333-000'
END AS telefono,
```

- Cuando `i` es múltiplo de 3 → `'999-111-000'`
- Cuando `i` deja residuo 1 al dividir por 3 → `'999-222-000'`
- Resto de casos → `'999-333-000'`

Así se distribuyen los valores de teléfono en **tres patrones distintos**.

### 5.2. Ejemplo: marcar algunos usuarios como administradores

```sql
CASE 
    WHEN i % 10 = 0 THEN TRUE
    ELSE FALSE
END AS es_admin
```

- 1 de cada 10 usuarios (`i` múltiplo de 10) tendrá `es_admin = TRUE`.
- El resto tendrá `es_admin = FALSE`.

---

## 6. Ejemplo completo de inserción masiva

Unimos todos los elementos anteriores en una sola sentencia:

```sql
INSERT INTO usuario (nombres, apellidos, email, password, telefono, es_admin)
SELECT
    'skill_nombre_'   || i                  AS nombres,
    'skill_apellido_' || i                  AS apellidos,
    LOWER('skill' || i || '@skill.com')     AS email,
    MD5(random()::TEXT)                     AS password,
    CASE
        WHEN i % 3 = 0 THEN '999-111-000'
        WHEN i % 3 = 1 THEN '999-222-000'
        ELSE              '999-333-000'
    END                                     AS telefono,
    CASE 
        WHEN i % 10 = 0 THEN TRUE
        ELSE FALSE
    END                                     AS es_admin
FROM generate_series(1, 100) AS i;
```

¿Qué logra esta consulta?

- Inserta **100 registros** en la tabla `usuario`.
- Cada usuario tiene:
  - Nombre y apellido diferenciados (`skill_nombre_i`, `skill_apellido_i`).
  - Email único (`skill{i}@skill.com`).
  - Contraseña aleatoria (hash MD5 de un número aleatorio).
  - Teléfono asignado según el patrón del `CASE`.
  - Campo `es_admin` verdadero solo para ciertos registros.

---

## 7. Verificación de los datos insertados

Después de ejecutar el `INSERT`, puedes verificar:

```sql
-- Ver todas las filas
SELECT * FROM usuario;

-- Contar cuántos registros hay
SELECT COUNT(*) FROM usuario;

-- Ver cuántos administradores se generaron
SELECT es_admin, COUNT(*)
FROM usuario
GROUP BY es_admin;
```

Si además tu tabla `usuario` tiene un `UUID` como clave primaria con `DEFAULT uuid_generate_v4()` o `gen_random_uuid()`:

- Verás que cada fila tiene un **UUID distinto** generado automáticamente.
- No necesitas indicarlo en el `INSERT`.

---

## 8. Opcional: reiniciar pruebas

Si quieres repetir la inserción desde cero durante las prácticas:

```sql
-- Eliminar todos los registros de la tabla (manteniendo estructura e IDs)
TRUNCATE TABLE usuario RESTART IDENTITY;

-- O, si usas UUID y quieres solo vaciar los datos:
TRUNCATE TABLE usuario;
```

> `RESTART IDENTITY` reinicia contadores de columnas tipo `SERIAL` / `IDENTITY`.  
> Para `UUID`, no es necesario, ya que cada valor se genera de forma independiente.

---

Con estas técnicas puedes crear en segundos **decenas o cientos de registros de prueba**, ideales para:

- Probar paginación.
- Evaluar rendimiento de consultas.
- Simular escenarios reales durante el desarrollo.